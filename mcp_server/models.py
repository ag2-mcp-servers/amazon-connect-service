# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T10:25:48+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, SecretStr, conint, constr


class ARN(RootModel[str]):
    root: str


class AccessDeniedException(RootModel[Any]):
    root: Any


class ActionType(Enum):
    CREATE_TASK = 'CREATE_TASK'
    ASSIGN_CONTACT_CATEGORY = 'ASSIGN_CONTACT_CATEGORY'
    GENERATE_EVENTBRIDGE_EVENT = 'GENERATE_EVENTBRIDGE_EVENT'
    SEND_NOTIFICATION = 'SEND_NOTIFICATION'


class AfterContactWorkTimeLimit(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class AgentFirstName(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class AgentLastName(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class AgentResourceId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class AgentStatusDescription(RootModel[constr(min_length=1, max_length=250)]):
    root: constr(min_length=1, max_length=250)


class AgentStatusId(RootModel[str]):
    root: str


class AgentStatusName(RootModel[constr(min_length=1, max_length=127)]):
    root: constr(min_length=1, max_length=127)


class AgentStatusOrderNumber(RootModel[conint(ge=1, le=50)]):
    root: conint(ge=1, le=50)


class AgentStatusState(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class AgentStatusType(Enum):
    ROUTABLE = 'ROUTABLE'
    CUSTOM = 'CUSTOM'
    OFFLINE = 'OFFLINE'


class AgentStatusTypes(RootModel[List[AgentStatusType]]):
    root: List[AgentStatusType] = Field(..., max_length=3)


class AgentUsername(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class AliasArn(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class ApproximateTotalCount(RootModel[int]):
    root: int


class AssignContactCategoryActionDefinition(BaseModel):
    pass


class AssociateDefaultVocabularyResponse(BaseModel):
    pass


class AssociationId(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class AttributeName(RootModel[constr(min_length=1, max_length=32767)]):
    root: constr(min_length=1, max_length=32767)


class AttributeValue(RootModel[constr(min_length=0, max_length=32767)]):
    root: constr(min_length=0, max_length=32767)


class Attributes(RootModel[Optional[Dict[str, AttributeValue]]]):
    root: Optional[Dict[str, AttributeValue]] = None


class AutoAccept(RootModel[bool]):
    root: bool


class AwsRegion(
    RootModel[
        constr(pattern=r'[a-z]{2}(-[a-z]+){1,2}(-[0-9])?', min_length=8, max_length=31)
    ]
):
    root: constr(
        pattern=r'[a-z]{2}(-[a-z]+){1,2}(-[0-9])?', min_length=8, max_length=31
    )


class BehaviorType(Enum):
    ROUTE_CURRENT_CHANNEL_ONLY = 'ROUTE_CURRENT_CHANNEL_ONLY'
    ROUTE_ANY_CHANNEL = 'ROUTE_ANY_CHANNEL'


class Boolean(RootModel[bool]):
    root: bool


class BotName(RootModel[constr(max_length=50)]):
    root: constr(max_length=50)


class BucketName(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class CampaignId(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class Channel(Enum):
    VOICE = 'VOICE'
    CHAT = 'CHAT'
    TASK = 'TASK'


class Channels(RootModel[List[Channel]]):
    root: List[Channel] = Field(..., max_length=3)


class ChatContent(RootModel[constr(min_length=1, max_length=16384)]):
    root: constr(min_length=1, max_length=16384)


class ChatContentType(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class ChatDurationInMinutes(RootModel[conint(ge=60, le=10080)]):
    root: conint(ge=60, le=10080)


class ChatMessage(BaseModel):
    Content: ChatContent
    ContentType: ChatContentType


class ChatStreamingEndpointARN(RootModel[constr(min_length=1, max_length=350)]):
    root: constr(min_length=1, max_length=350)


class ClientToken(RootModel[constr(max_length=500)]):
    root: constr(max_length=500)


class CommonNameLength127(RootModel[constr(min_length=1, max_length=127)]):
    root: constr(min_length=1, max_length=127)


class Comparison(Enum):
    LT = 'LT'


class Concurrency(RootModel[conint(ge=1, le=10)]):
    root: conint(ge=1, le=10)


class ContactFlowContent(RootModel[str]):
    root: str


class ContactFlowDescription(RootModel[str]):
    root: str


class ContactFlowId(RootModel[constr(max_length=500)]):
    root: constr(max_length=500)


class ContactFlowModuleContent(RootModel[constr(min_length=1, max_length=256000)]):
    root: constr(min_length=1, max_length=256000)


class ContactFlowModuleDescription(
    RootModel[constr(pattern=r'.*\S.*', min_length=0, max_length=500)]
):
    root: constr(pattern=r'.*\S.*', min_length=0, max_length=500)


class ContactFlowModuleId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class ContactFlowModuleName(
    RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=127)]
):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=127)


class ContactFlowModuleState(Enum):
    ACTIVE = 'ACTIVE'
    ARCHIVED = 'ARCHIVED'


class ContactFlowModuleStatus(Enum):
    PUBLISHED = 'PUBLISHED'
    SAVED = 'SAVED'


class ContactFlowModuleSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[ContactFlowModuleId] = None
    Name: Optional[ContactFlowModuleName] = None
    State: Optional[ContactFlowModuleState] = None


class ContactFlowModulesSummaryList(RootModel[List[ContactFlowModuleSummary]]):
    root: List[ContactFlowModuleSummary]


class ContactFlowName(RootModel[constr(min_length=1)]):
    root: constr(min_length=1)


class ContactFlowNotPublishedException(RootModel[Any]):
    root: Any


class ContactFlowState(Enum):
    ACTIVE = 'ACTIVE'
    ARCHIVED = 'ARCHIVED'


class ContactFlowType(Enum):
    CONTACT_FLOW = 'CONTACT_FLOW'
    CUSTOMER_QUEUE = 'CUSTOMER_QUEUE'
    CUSTOMER_HOLD = 'CUSTOMER_HOLD'
    CUSTOMER_WHISPER = 'CUSTOMER_WHISPER'
    AGENT_HOLD = 'AGENT_HOLD'
    AGENT_WHISPER = 'AGENT_WHISPER'
    OUTBOUND_WHISPER = 'OUTBOUND_WHISPER'
    AGENT_TRANSFER = 'AGENT_TRANSFER'
    QUEUE_TRANSFER = 'QUEUE_TRANSFER'


class ContactFlowTypes(RootModel[List[ContactFlowType]]):
    root: List[ContactFlowType] = Field(..., max_length=10)


class ContactId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class ContactInitiationMethod(Enum):
    INBOUND = 'INBOUND'
    OUTBOUND = 'OUTBOUND'
    TRANSFER = 'TRANSFER'
    QUEUE_TRANSFER = 'QUEUE_TRANSFER'
    CALLBACK = 'CALLBACK'
    API = 'API'
    DISCONNECT = 'DISCONNECT'
    MONITOR = 'MONITOR'


class ContactNotFoundException(RootModel[Any]):
    root: Any


class ContactState(Enum):
    INCOMING = 'INCOMING'
    PENDING = 'PENDING'
    CONNECTING = 'CONNECTING'
    CONNECTED = 'CONNECTED'
    CONNECTED_ONHOLD = 'CONNECTED_ONHOLD'
    MISSED = 'MISSED'
    ERROR = 'ERROR'
    ENDED = 'ENDED'
    REJECTED = 'REJECTED'


class ContactStates(RootModel[List[ContactState]]):
    root: List[ContactState] = Field(..., max_length=9)


class Content(RootModel[constr(min_length=1, max_length=1024)]):
    root: constr(min_length=1, max_length=1024)


class CreateAgentStatusResponse(BaseModel):
    AgentStatusARN: Optional[ARN] = None
    AgentStatusId_1: Optional[AgentStatusId] = Field(None, alias='AgentStatusId')


class CreateContactFlowModuleResponse(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[ContactFlowModuleId] = None


class CreateContactFlowResponse(BaseModel):
    ContactFlowArn: Optional[ARN] = None
    ContactFlowId_1: Optional[ContactFlowId] = Field(None, alias='ContactFlowId')


class CreateSecurityProfileName(
    RootModel[constr(pattern=r'^[ a-zA-Z0-9_@-]+$', min_length=1, max_length=127)]
):
    root: constr(pattern=r'^[ a-zA-Z0-9_@-]+$', min_length=1, max_length=127)


class CrossChannelBehavior(BaseModel):
    BehaviorType_1: BehaviorType = Field(..., alias='BehaviorType')


class CurrentMetricName(Enum):
    AGENTS_ONLINE = 'AGENTS_ONLINE'
    AGENTS_AVAILABLE = 'AGENTS_AVAILABLE'
    AGENTS_ON_CALL = 'AGENTS_ON_CALL'
    AGENTS_NON_PRODUCTIVE = 'AGENTS_NON_PRODUCTIVE'
    AGENTS_AFTER_CONTACT_WORK = 'AGENTS_AFTER_CONTACT_WORK'
    AGENTS_ERROR = 'AGENTS_ERROR'
    AGENTS_STAFFED = 'AGENTS_STAFFED'
    CONTACTS_IN_QUEUE = 'CONTACTS_IN_QUEUE'
    OLDEST_CONTACT_AGE = 'OLDEST_CONTACT_AGE'
    CONTACTS_SCHEDULED = 'CONTACTS_SCHEDULED'
    AGENTS_ON_CONTACT = 'AGENTS_ON_CONTACT'
    SLOTS_ACTIVE = 'SLOTS_ACTIVE'
    SLOTS_AVAILABLE = 'SLOTS_AVAILABLE'


class Delay(RootModel[conint(ge=0, le=9999)]):
    root: conint(ge=0, le=9999)


class DeleteContactFlowModuleRequest(BaseModel):
    pass


class DeleteContactFlowModuleResponse(BaseModel):
    pass


class DeleteContactFlowRequest(BaseModel):
    pass


class DeleteContactFlowResponse(BaseModel):
    pass


class DeleteHoursOfOperationRequest(BaseModel):
    pass


class DeleteInstanceRequest(BaseModel):
    pass


class DeleteIntegrationAssociationRequest(BaseModel):
    pass


class DeleteQuickConnectRequest(BaseModel):
    pass


class DeleteRuleRequest(BaseModel):
    pass


class DeleteSecurityProfileRequest(BaseModel):
    pass


class DeleteTaskTemplateRequest(BaseModel):
    pass


class DeleteTaskTemplateResponse(BaseModel):
    pass


class DeleteTrafficDistributionGroupRequest(BaseModel):
    pass


class DeleteTrafficDistributionGroupResponse(BaseModel):
    pass


class DeleteUseCaseRequest(BaseModel):
    pass


class DeleteUserHierarchyGroupRequest(BaseModel):
    pass


class DeleteUserRequest(BaseModel):
    pass


class DeleteVocabularyRequest(BaseModel):
    pass


class DescribeAgentStatusRequest(BaseModel):
    pass


class DescribeContactFlowModuleRequest(BaseModel):
    pass


class DescribeContactFlowRequest(BaseModel):
    pass


class DescribeContactRequest(BaseModel):
    pass


class DescribeHoursOfOperationRequest(BaseModel):
    pass


class DescribeInstanceAttributeRequest(BaseModel):
    pass


class DescribeInstanceRequest(BaseModel):
    pass


class DescribeInstanceStorageConfigRequest(BaseModel):
    pass


class DescribePhoneNumberRequest(BaseModel):
    pass


class DescribeQueueRequest(BaseModel):
    pass


class DescribeQuickConnectRequest(BaseModel):
    pass


class DescribeRoutingProfileRequest(BaseModel):
    pass


class DescribeRuleRequest(BaseModel):
    pass


class DescribeSecurityProfileRequest(BaseModel):
    pass


class DescribeTrafficDistributionGroupRequest(BaseModel):
    pass


class DescribeUserHierarchyGroupRequest(BaseModel):
    pass


class DescribeUserHierarchyStructureRequest(BaseModel):
    pass


class DescribeUserRequest(BaseModel):
    pass


class DescribeVocabularyRequest(BaseModel):
    pass


class Description(RootModel[constr(min_length=0, max_length=4096)]):
    root: constr(min_length=0, max_length=4096)


class Description250(
    RootModel[constr(pattern=r'(^[\S].*[\S]$)|(^[\S]$)', min_length=1, max_length=250)]
):
    root: constr(pattern=r'(^[\S].*[\S]$)|(^[\S]$)', min_length=1, max_length=250)


class DestinationNotAllowedException(RootModel[Any]):
    root: Any


class DimensionsV2Key(RootModel[str]):
    root: str


class DimensionsV2Value(RootModel[str]):
    root: str


class DirectoryAlias(RootModel[SecretStr]):
    root: SecretStr


class DirectoryId(
    RootModel[constr(pattern=r'^d-[0-9a-f]{10}$', min_length=12, max_length=12)]
):
    root: constr(pattern=r'^d-[0-9a-f]{10}$', min_length=12, max_length=12)


class DirectoryType(Enum):
    SAML = 'SAML'
    CONNECT_MANAGED = 'CONNECT_MANAGED'
    EXISTING_DIRECTORY = 'EXISTING_DIRECTORY'


class DirectoryUserId(RootModel[str]):
    root: str


class DisassociateApprovedOriginRequest(BaseModel):
    pass


class DisassociateInstanceStorageConfigRequest(BaseModel):
    pass


class DisassociateLambdaFunctionRequest(BaseModel):
    pass


class DisassociateLexBotRequest(BaseModel):
    pass


class DisassociatePhoneNumberContactFlowRequest(BaseModel):
    pass


class DisassociateSecurityKeyRequest(BaseModel):
    pass


class DismissUserContactRequest(BaseModel):
    ContactId_1: ContactId = Field(..., alias='ContactId')


class DismissUserContactResponse(BaseModel):
    pass


class DisplayName(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class DuplicateResourceException(RootModel[Any]):
    root: Any


class Email(RootModel[str]):
    root: str


class EncryptionType(Enum):
    KMS = 'KMS'


class EventBridgeActionName(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class EventSourceName(Enum):
    OnPostCallAnalysisAvailable = 'OnPostCallAnalysisAvailable'
    OnRealTimeCallAnalysisAvailable = 'OnRealTimeCallAnalysisAvailable'
    OnPostChatAnalysisAvailable = 'OnPostChatAnalysisAvailable'
    OnZendeskTicketCreate = 'OnZendeskTicketCreate'
    OnZendeskTicketStatusUpdate = 'OnZendeskTicketStatusUpdate'
    OnSalesforceCaseCreate = 'OnSalesforceCaseCreate'


class FunctionArn(RootModel[constr(min_length=1, max_length=140)]):
    root: constr(min_length=1, max_length=140)


class FunctionArnsList(RootModel[List[FunctionArn]]):
    root: List[FunctionArn]


class GetContactAttributesRequest(BaseModel):
    pass


class GetContactAttributesResponse(BaseModel):
    Attributes_1: Optional[Attributes] = Field(None, alias='Attributes')


class GetFederationTokenRequest(BaseModel):
    pass


class GetTaskTemplateRequest(BaseModel):
    pass


class GetTrafficDistributionRequest(BaseModel):
    pass


class Grouping(Enum):
    QUEUE = 'QUEUE'
    CHANNEL = 'CHANNEL'
    ROUTING_PROFILE = 'ROUTING_PROFILE'


class GroupingV2(RootModel[str]):
    root: str


class Groupings(RootModel[List[Grouping]]):
    root: List[Grouping] = Field(..., max_length=2)


class GroupingsV2(RootModel[List[GroupingV2]]):
    root: List[GroupingV2] = Field(..., max_length=2)


class HierarchyGroupId(RootModel[str]):
    root: str


class HierarchyGroupMatchType(Enum):
    EXACT = 'EXACT'
    WITH_CHILD_GROUPS = 'WITH_CHILD_GROUPS'


class HierarchyGroupName(RootModel[str]):
    root: str


class HierarchyGroupSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[HierarchyGroupId] = None
    Name: Optional[HierarchyGroupName] = None


class HierarchyGroupSummaryList(RootModel[List[HierarchyGroupSummary]]):
    root: List[HierarchyGroupSummary]


class HierarchyGroupSummaryReference(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[HierarchyGroupId] = None


class HierarchyLevelId(RootModel[str]):
    root: str


class HierarchyLevelName(RootModel[str]):
    root: str


class HierarchyLevelUpdate(BaseModel):
    Name: HierarchyLevelName


class HierarchyPath(BaseModel):
    LevelFive: Optional[HierarchyGroupSummary] = None
    LevelFour: Optional[HierarchyGroupSummary] = None
    LevelOne: Optional[HierarchyGroupSummary] = None
    LevelThree: Optional[HierarchyGroupSummary] = None
    LevelTwo: Optional[HierarchyGroupSummary] = None


class HierarchyPathReference(BaseModel):
    LevelFive: Optional[HierarchyGroupSummaryReference] = None
    LevelFour: Optional[HierarchyGroupSummaryReference] = None
    LevelOne: Optional[HierarchyGroupSummaryReference] = None
    LevelThree: Optional[HierarchyGroupSummaryReference] = None
    LevelTwo: Optional[HierarchyGroupSummaryReference] = None


class HierarchyStructureUpdate(BaseModel):
    LevelFive: Optional[HierarchyLevelUpdate] = None
    LevelFour: Optional[HierarchyLevelUpdate] = None
    LevelOne: Optional[HierarchyLevelUpdate] = None
    LevelThree: Optional[HierarchyLevelUpdate] = None
    LevelTwo: Optional[HierarchyLevelUpdate] = None


class HistoricalMetricName(Enum):
    CONTACTS_QUEUED = 'CONTACTS_QUEUED'
    CONTACTS_HANDLED = 'CONTACTS_HANDLED'
    CONTACTS_ABANDONED = 'CONTACTS_ABANDONED'
    CONTACTS_CONSULTED = 'CONTACTS_CONSULTED'
    CONTACTS_AGENT_HUNG_UP_FIRST = 'CONTACTS_AGENT_HUNG_UP_FIRST'
    CONTACTS_HANDLED_INCOMING = 'CONTACTS_HANDLED_INCOMING'
    CONTACTS_HANDLED_OUTBOUND = 'CONTACTS_HANDLED_OUTBOUND'
    CONTACTS_HOLD_ABANDONS = 'CONTACTS_HOLD_ABANDONS'
    CONTACTS_TRANSFERRED_IN = 'CONTACTS_TRANSFERRED_IN'
    CONTACTS_TRANSFERRED_OUT = 'CONTACTS_TRANSFERRED_OUT'
    CONTACTS_TRANSFERRED_IN_FROM_QUEUE = 'CONTACTS_TRANSFERRED_IN_FROM_QUEUE'
    CONTACTS_TRANSFERRED_OUT_FROM_QUEUE = 'CONTACTS_TRANSFERRED_OUT_FROM_QUEUE'
    CONTACTS_MISSED = 'CONTACTS_MISSED'
    CALLBACK_CONTACTS_HANDLED = 'CALLBACK_CONTACTS_HANDLED'
    API_CONTACTS_HANDLED = 'API_CONTACTS_HANDLED'
    OCCUPANCY = 'OCCUPANCY'
    HANDLE_TIME = 'HANDLE_TIME'
    AFTER_CONTACT_WORK_TIME = 'AFTER_CONTACT_WORK_TIME'
    QUEUED_TIME = 'QUEUED_TIME'
    ABANDON_TIME = 'ABANDON_TIME'
    QUEUE_ANSWER_TIME = 'QUEUE_ANSWER_TIME'
    HOLD_TIME = 'HOLD_TIME'
    INTERACTION_TIME = 'INTERACTION_TIME'
    INTERACTION_AND_HOLD_TIME = 'INTERACTION_AND_HOLD_TIME'
    SERVICE_LEVEL = 'SERVICE_LEVEL'


class Hours(RootModel[conint(ge=0, le=87600)]):
    root: conint(ge=0, le=87600)


class Hours24Format(RootModel[conint(ge=0, le=23)]):
    root: conint(ge=0, le=23)


class HoursOfOperationDays(Enum):
    SUNDAY = 'SUNDAY'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'


class HoursOfOperationDescription(RootModel[constr(min_length=1, max_length=250)]):
    root: constr(min_length=1, max_length=250)


class HoursOfOperationId(RootModel[str]):
    root: str


class HoursOfOperationName(RootModel[str]):
    root: str


class HoursOfOperationSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[HoursOfOperationId] = None
    Name: Optional[HoursOfOperationName] = None


class HoursOfOperationSummaryList(RootModel[List[HoursOfOperationSummary]]):
    root: List[HoursOfOperationSummary]


class ISO8601Datetime(RootModel[str]):
    root: str


class IdempotencyException(RootModel[Any]):
    root: Any


class InboundCallsEnabled(RootModel[bool]):
    root: bool


class InstanceArn(
    RootModel[
        constr(
            pattern=r'arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9-]{1}:[0-9]{1,20}:instance/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
        )
    ]
):
    root: constr(
        pattern=r'arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9-]{1}:[0-9]{1,20}:instance/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
    )


class InstanceAttributeType(Enum):
    INBOUND_CALLS = 'INBOUND_CALLS'
    OUTBOUND_CALLS = 'OUTBOUND_CALLS'
    CONTACTFLOW_LOGS = 'CONTACTFLOW_LOGS'
    CONTACT_LENS = 'CONTACT_LENS'
    AUTO_RESOLVE_BEST_VOICES = 'AUTO_RESOLVE_BEST_VOICES'
    USE_CUSTOM_TTS_VOICES = 'USE_CUSTOM_TTS_VOICES'
    EARLY_MEDIA = 'EARLY_MEDIA'
    MULTI_PARTY_CONFERENCE = 'MULTI_PARTY_CONFERENCE'
    HIGH_VOLUME_OUTBOUND = 'HIGH_VOLUME_OUTBOUND'
    ENHANCED_CONTACT_MONITORING = 'ENHANCED_CONTACT_MONITORING'


class InstanceAttributeValue(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class InstanceId(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class InstanceIdOrArn(
    RootModel[
        constr(
            pattern=r'^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$',
            min_length=1,
            max_length=250,
        )
    ]
):
    root: constr(
        pattern=r'^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$',
        min_length=1,
        max_length=250,
    )


class InstanceStatus(Enum):
    CREATION_IN_PROGRESS = 'CREATION_IN_PROGRESS'
    ACTIVE = 'ACTIVE'
    CREATION_FAILED = 'CREATION_FAILED'


class InstanceStorageResourceType(Enum):
    CHAT_TRANSCRIPTS = 'CHAT_TRANSCRIPTS'
    CALL_RECORDINGS = 'CALL_RECORDINGS'
    SCHEDULED_REPORTS = 'SCHEDULED_REPORTS'
    MEDIA_STREAMS = 'MEDIA_STREAMS'
    CONTACT_TRACE_RECORDS = 'CONTACT_TRACE_RECORDS'
    AGENT_EVENTS = 'AGENT_EVENTS'
    REAL_TIME_CONTACT_ANALYSIS_SEGMENTS = 'REAL_TIME_CONTACT_ANALYSIS_SEGMENTS'
    ATTACHMENTS = 'ATTACHMENTS'
    CONTACT_EVALUATIONS = 'CONTACT_EVALUATIONS'


class IntegerCount(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class IntegrationAssociationId(RootModel[constr(min_length=1, max_length=200)]):
    root: constr(min_length=1, max_length=200)


class IntegrationType(Enum):
    EVENT = 'EVENT'
    VOICE_ID = 'VOICE_ID'
    PINPOINT_APP = 'PINPOINT_APP'
    WISDOM_ASSISTANT = 'WISDOM_ASSISTANT'
    WISDOM_KNOWLEDGE_BASE = 'WISDOM_KNOWLEDGE_BASE'
    CASES_DOMAIN = 'CASES_DOMAIN'


class InternalServiceException(RootModel[Any]):
    root: Any


class InvalidContactFlowException(RootModel[Any]):
    root: Any


class InvalidContactFlowModuleException(RootModel[Any]):
    root: Any


class InvalidParameterException(RootModel[Any]):
    root: Any


class InvalidRequestException(RootModel[Any]):
    root: Any


class KeyId(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class KinesisFirehoseConfig(BaseModel):
    FirehoseArn: ARN


class KinesisStreamConfig(BaseModel):
    StreamArn: ARN


class LargeNextToken(RootModel[constr(min_length=1, max_length=100000)]):
    root: constr(min_length=1, max_length=100000)


class LexRegion(RootModel[constr(max_length=60)]):
    root: constr(max_length=60)


class LexV2Bot(BaseModel):
    AliasArn_1: Optional[AliasArn] = Field(None, alias='AliasArn')


class LexVersion(Enum):
    V1 = 'V1'
    V2 = 'V2'


class LimitExceededException(RootModel[Any]):
    root: Any


class ListAgentStatusRequest(BaseModel):
    pass


class ListApprovedOriginsRequest(BaseModel):
    pass


class ListBotsRequest(BaseModel):
    pass


class ListContactFlowModulesRequest(BaseModel):
    pass


class ListContactFlowsRequest(BaseModel):
    pass


class ListContactReferencesRequest(BaseModel):
    pass


class ListHoursOfOperationsRequest(BaseModel):
    pass


class ListInstanceAttributesRequest(BaseModel):
    pass


class ListInstanceStorageConfigsRequest(BaseModel):
    pass


class ListInstancesRequest(BaseModel):
    pass


class ListIntegrationAssociationsRequest(BaseModel):
    pass


class ListLambdaFunctionsRequest(BaseModel):
    pass


class ListLexBotsRequest(BaseModel):
    pass


class ListPhoneNumbersRequest(BaseModel):
    pass


class ListPromptsRequest(BaseModel):
    pass


class ListQueueQuickConnectsRequest(BaseModel):
    pass


class ListQueuesRequest(BaseModel):
    pass


class ListQuickConnectsRequest(BaseModel):
    pass


class ListRoutingProfileQueuesRequest(BaseModel):
    pass


class ListRoutingProfilesRequest(BaseModel):
    pass


class ListRulesRequest(BaseModel):
    pass


class ListSecurityKeysRequest(BaseModel):
    pass


class ListSecurityProfilePermissionsRequest(BaseModel):
    pass


class ListSecurityProfilesRequest(BaseModel):
    pass


class ListTagsForResourceRequest(BaseModel):
    pass


class ListTaskTemplatesRequest(BaseModel):
    pass


class ListTrafficDistributionGroupsRequest(BaseModel):
    pass


class ListUseCasesRequest(BaseModel):
    pass


class ListUserHierarchyGroupsRequest(BaseModel):
    pass


class ListUsersRequest(BaseModel):
    pass


class Long(RootModel[int]):
    root: int


class MaxResult10(RootModel[conint(ge=1, le=10)]):
    root: conint(ge=1, le=10)


class MaxResult100(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class MaxResult1000(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class MaxResult2(RootModel[conint(ge=1, le=2)]):
    root: conint(ge=1, le=2)


class MaxResult200(RootModel[conint(ge=1, le=200)]):
    root: conint(ge=1, le=200)


class MaxResult25(RootModel[conint(ge=1, le=25)]):
    root: conint(ge=1, le=25)


class MaxResult7(RootModel[conint(ge=1, le=7)]):
    root: conint(ge=1, le=7)


class MediaConcurrency(BaseModel):
    Channel_1: Channel = Field(..., alias='Channel')
    Concurrency_1: Concurrency = Field(..., alias='Concurrency')
    CrossChannelBehavior_1: Optional[CrossChannelBehavior] = Field(
        None, alias='CrossChannelBehavior'
    )


class MetricNameV2(RootModel[str]):
    root: str


class MinutesLimit60(RootModel[conint(ge=0, le=59)]):
    root: conint(ge=0, le=59)


class MonitorCapability(Enum):
    SILENT_MONITOR = 'SILENT_MONITOR'
    BARGE = 'BARGE'


class MonitorContactResponse(BaseModel):
    ContactArn: Optional[ARN] = None
    ContactId_1: Optional[ContactId] = Field(None, alias='ContactId')


class Name(RootModel[constr(min_length=0, max_length=512)]):
    root: constr(min_length=0, max_length=512)


class Name128(
    RootModel[constr(pattern=r'(^[\S].*[\S]$)|(^[\S]$)', min_length=1, max_length=128)]
):
    root: constr(pattern=r'(^[\S].*[\S]$)|(^[\S]$)', min_length=1, max_length=128)


class NextToken(RootModel[str]):
    root: str


class NextToken2500(RootModel[constr(min_length=1, max_length=2500)]):
    root: constr(min_length=1, max_length=2500)


class NotificationContentType(Enum):
    PLAIN_TEXT = 'PLAIN_TEXT'


class NotificationDeliveryType(Enum):
    EMAIL = 'EMAIL'


class Origin(RootModel[constr(max_length=267)]):
    root: constr(max_length=267)


class OriginsList(RootModel[List[Origin]]):
    root: List[Origin]


class OutboundCallerIdName(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class OutboundCallsEnabled(RootModel[bool]):
    root: bool


class OutboundContactNotPermittedException(RootModel[Any]):
    root: Any


class PEM(RootModel[constr(min_length=1, max_length=1024)]):
    root: constr(min_length=1, max_length=1024)


class ParticipantDetails(BaseModel):
    DisplayName_1: DisplayName = Field(..., alias='DisplayName')


class ParticipantId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class ParticipantRole(Enum):
    AGENT = 'AGENT'
    CUSTOMER = 'CUSTOMER'
    SYSTEM = 'SYSTEM'
    CUSTOM_BOT = 'CUSTOM_BOT'


class ParticipantTimerAction(Enum):
    Unset = 'Unset'


class ParticipantTimerDurationInMinutes(RootModel[conint(ge=2, le=480)]):
    root: conint(ge=2, le=480)


class ParticipantTimerType(Enum):
    IDLE = 'IDLE'
    DISCONNECT_NONCUSTOMER = 'DISCONNECT_NONCUSTOMER'


class ParticipantTimerValue(BaseModel):
    ParticipantTimerAction_1: Optional[ParticipantTimerAction] = Field(
        None, alias='ParticipantTimerAction'
    )
    ParticipantTimerDurationInMinutes_1: Optional[ParticipantTimerDurationInMinutes] = (
        Field(None, alias='ParticipantTimerDurationInMinutes')
    )


class ParticipantToken(RootModel[constr(min_length=1, max_length=1000)]):
    root: constr(min_length=1, max_length=1000)


class ParticipantTokenCredentials(BaseModel):
    Expiry: Optional[ISO8601Datetime] = None
    ParticipantToken_1: Optional[ParticipantToken] = Field(
        None, alias='ParticipantToken'
    )


class Password(
    RootModel[constr(pattern=r'/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d\S]{8,64}$/')]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d\S]{8,64}$/')


class Percentage(RootModel[conint(ge=0, le=100)]):
    root: conint(ge=0, le=100)


class PhoneNumber(RootModel[constr(pattern=r'\\+[1-9]\\d{1,14}$')]):
    root: constr(pattern=r'\\+[1-9]\\d{1,14}$')


class PhoneNumberCountryCode(Enum):
    AF = 'AF'
    AL = 'AL'
    DZ = 'DZ'
    AS = 'AS'
    AD = 'AD'
    AO = 'AO'
    AI = 'AI'
    AQ = 'AQ'
    AG = 'AG'
    AR = 'AR'
    AM = 'AM'
    AW = 'AW'
    AU = 'AU'
    AT = 'AT'
    AZ = 'AZ'
    BS = 'BS'
    BH = 'BH'
    BD = 'BD'
    BB = 'BB'
    BY = 'BY'
    BE = 'BE'
    BZ = 'BZ'
    BJ = 'BJ'
    BM = 'BM'
    BT = 'BT'
    BO = 'BO'
    BA = 'BA'
    BW = 'BW'
    BR = 'BR'
    IO = 'IO'
    VG = 'VG'
    BN = 'BN'
    BG = 'BG'
    BF = 'BF'
    BI = 'BI'
    KH = 'KH'
    CM = 'CM'
    CA = 'CA'
    CV = 'CV'
    KY = 'KY'
    CF = 'CF'
    TD = 'TD'
    CL = 'CL'
    CN = 'CN'
    CX = 'CX'
    CC = 'CC'
    CO = 'CO'
    KM = 'KM'
    CK = 'CK'
    CR = 'CR'
    HR = 'HR'
    CU = 'CU'
    CW = 'CW'
    CY = 'CY'
    CZ = 'CZ'
    CD = 'CD'
    DK = 'DK'
    DJ = 'DJ'
    DM = 'DM'
    DO = 'DO'
    TL = 'TL'
    EC = 'EC'
    EG = 'EG'
    SV = 'SV'
    GQ = 'GQ'
    ER = 'ER'
    EE = 'EE'
    ET = 'ET'
    FK = 'FK'
    FO = 'FO'
    FJ = 'FJ'
    FI = 'FI'
    FR = 'FR'
    PF = 'PF'
    GA = 'GA'
    GM = 'GM'
    GE = 'GE'
    DE = 'DE'
    GH = 'GH'
    GI = 'GI'
    GR = 'GR'
    GL = 'GL'
    GD = 'GD'
    GU = 'GU'
    GT = 'GT'
    GG = 'GG'
    GN = 'GN'
    GW = 'GW'
    GY = 'GY'
    HT = 'HT'
    HN = 'HN'
    HK = 'HK'
    HU = 'HU'
    IS = 'IS'
    IN = 'IN'
    ID = 'ID'
    IR = 'IR'
    IQ = 'IQ'
    IE = 'IE'
    IM = 'IM'
    IL = 'IL'
    IT = 'IT'
    CI = 'CI'
    JM = 'JM'
    JP = 'JP'
    JE = 'JE'
    JO = 'JO'
    KZ = 'KZ'
    KE = 'KE'
    KI = 'KI'
    KW = 'KW'
    KG = 'KG'
    LA = 'LA'
    LV = 'LV'
    LB = 'LB'
    LS = 'LS'
    LR = 'LR'
    LY = 'LY'
    LI = 'LI'
    LT = 'LT'
    LU = 'LU'
    MO = 'MO'
    MK = 'MK'
    MG = 'MG'
    MW = 'MW'
    MY = 'MY'
    MV = 'MV'
    ML = 'ML'
    MT = 'MT'
    MH = 'MH'
    MR = 'MR'
    MU = 'MU'
    YT = 'YT'
    MX = 'MX'
    FM = 'FM'
    MD = 'MD'
    MC = 'MC'
    MN = 'MN'
    ME = 'ME'
    MS = 'MS'
    MA = 'MA'
    MZ = 'MZ'
    MM = 'MM'
    NA = 'NA'
    NR = 'NR'
    NP = 'NP'
    NL = 'NL'
    AN = 'AN'
    NC = 'NC'
    NZ = 'NZ'
    NI = 'NI'
    NE = 'NE'
    NG = 'NG'
    NU = 'NU'
    KP = 'KP'
    MP = 'MP'
    NO = 'NO'
    OM = 'OM'
    PK = 'PK'
    PW = 'PW'
    PA = 'PA'
    PG = 'PG'
    PY = 'PY'
    PE = 'PE'
    PH = 'PH'
    PN = 'PN'
    PL = 'PL'
    PT = 'PT'
    PR = 'PR'
    QA = 'QA'
    CG = 'CG'
    RE = 'RE'
    RO = 'RO'
    RU = 'RU'
    RW = 'RW'
    BL = 'BL'
    SH = 'SH'
    KN = 'KN'
    LC = 'LC'
    MF = 'MF'
    PM = 'PM'
    VC = 'VC'
    WS = 'WS'
    SM = 'SM'
    ST = 'ST'
    SA = 'SA'
    SN = 'SN'
    RS = 'RS'
    SC = 'SC'
    SL = 'SL'
    SG = 'SG'
    SX = 'SX'
    SK = 'SK'
    SI = 'SI'
    SB = 'SB'
    SO = 'SO'
    ZA = 'ZA'
    KR = 'KR'
    ES = 'ES'
    LK = 'LK'
    SD = 'SD'
    SR = 'SR'
    SJ = 'SJ'
    SZ = 'SZ'
    SE = 'SE'
    CH = 'CH'
    SY = 'SY'
    TW = 'TW'
    TJ = 'TJ'
    TZ = 'TZ'
    TH = 'TH'
    TG = 'TG'
    TK = 'TK'
    TO = 'TO'
    TT = 'TT'
    TN = 'TN'
    TR = 'TR'
    TM = 'TM'
    TC = 'TC'
    TV = 'TV'
    VI = 'VI'
    UG = 'UG'
    UA = 'UA'
    AE = 'AE'
    GB = 'GB'
    US = 'US'
    UY = 'UY'
    UZ = 'UZ'
    VU = 'VU'
    VA = 'VA'
    VE = 'VE'
    VN = 'VN'
    WF = 'WF'
    EH = 'EH'
    YE = 'YE'
    ZM = 'ZM'
    ZW = 'ZW'


class PhoneNumberCountryCodes(RootModel[List[PhoneNumberCountryCode]]):
    root: List[PhoneNumberCountryCode] = Field(..., max_length=10)


class PhoneNumberDescription(
    RootModel[constr(pattern=r'^[\W\S_]*', min_length=0, max_length=500)]
):
    root: constr(pattern=r'^[\W\S_]*', min_length=0, max_length=500)


class PhoneNumberId(RootModel[str]):
    root: str


class PhoneNumberPrefix(RootModel[constr(pattern=r'\\+?[0-9]{1,11}')]):
    root: constr(pattern=r'\\+?[0-9]{1,11}')


class PhoneNumberQuickConnectConfig(BaseModel):
    PhoneNumber_1: PhoneNumber = Field(..., alias='PhoneNumber')


class PhoneNumberType(Enum):
    TOLL_FREE = 'TOLL_FREE'
    DID = 'DID'


class PhoneNumberTypes(RootModel[List[PhoneNumberType]]):
    root: List[PhoneNumberType] = Field(..., max_length=2)


class PhoneNumberWorkflowMessage(
    RootModel[constr(pattern=r'^[\W\S_]*', min_length=0, max_length=255)]
):
    root: constr(pattern=r'^[\W\S_]*', min_length=0, max_length=255)


class PhoneNumberWorkflowStatus(Enum):
    CLAIMED = 'CLAIMED'
    IN_PROGRESS = 'IN_PROGRESS'
    FAILED = 'FAILED'


class PhoneType(Enum):
    SOFT_PHONE = 'SOFT_PHONE'
    DESK_PHONE = 'DESK_PHONE'


class Prefix(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class Priority(RootModel[conint(ge=1, le=99)]):
    root: conint(ge=1, le=99)


class PromptId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class PromptName(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class PromptSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[PromptId] = None
    Name: Optional[PromptName] = None


class PromptSummaryList(RootModel[List[PromptSummary]]):
    root: List[PromptSummary]


class PropertyValidationException(RootModel[Any]):
    root: Any


class PutUserStatusRequest(BaseModel):
    AgentStatusId_1: AgentStatusId = Field(..., alias='AgentStatusId')


class PutUserStatusResponse(BaseModel):
    pass


class QueueDescription(RootModel[constr(min_length=1, max_length=250)]):
    root: constr(min_length=1, max_length=250)


class QueueId(RootModel[str]):
    root: str


class QueueMaxContacts(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class QueueName(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class QueueQuickConnectConfig(BaseModel):
    ContactFlowId_1: ContactFlowId = Field(..., alias='ContactFlowId')
    QueueId_1: QueueId = Field(..., alias='QueueId')


class QueueReference(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[QueueId] = None


class QueueStatus(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class QueueType(Enum):
    STANDARD = 'STANDARD'
    AGENT = 'AGENT'


class QueueTypes(RootModel[List[QueueType]]):
    root: List[QueueType] = Field(..., max_length=2)


class Queues(RootModel[List[QueueId]]):
    root: List[QueueId] = Field(..., max_length=100, min_length=1)


class QuickConnectDescription(RootModel[constr(min_length=1, max_length=250)]):
    root: constr(min_length=1, max_length=250)


class QuickConnectId(RootModel[str]):
    root: str


class QuickConnectName(RootModel[constr(min_length=1, max_length=127)]):
    root: constr(min_length=1, max_length=127)


class QuickConnectType(Enum):
    USER = 'USER'
    QUEUE = 'QUEUE'
    PHONE_NUMBER = 'PHONE_NUMBER'


class QuickConnectTypes(RootModel[List[QuickConnectType]]):
    root: List[QuickConnectType] = Field(..., max_length=3)


class QuickConnectsList(RootModel[List[QuickConnectId]]):
    root: List[QuickConnectId] = Field(..., max_length=50, min_length=1)


class ReferenceKey(RootModel[constr(min_length=1, max_length=4096)]):
    root: constr(min_length=1, max_length=4096)


class ReferenceStatus(Enum):
    APPROVED = 'APPROVED'
    REJECTED = 'REJECTED'


class ReferenceType(Enum):
    URL = 'URL'
    ATTACHMENT = 'ATTACHMENT'
    NUMBER = 'NUMBER'
    STRING = 'STRING'
    DATE = 'DATE'
    EMAIL = 'EMAIL'


class ReferenceTypes(RootModel[List[ReferenceType]]):
    root: List[ReferenceType] = Field(..., max_length=6)


class ReferenceValue(RootModel[constr(min_length=0, max_length=4096)]):
    root: constr(min_length=0, max_length=4096)


class RehydrationType(Enum):
    ENTIRE_PAST_SESSION = 'ENTIRE_PAST_SESSION'
    FROM_SEGMENT = 'FROM_SEGMENT'


class ReleasePhoneNumberRequest(BaseModel):
    pass


class ReplicateInstanceRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    ReplicaAlias: DirectoryAlias
    ReplicaRegion: AwsRegion


class ReplicateInstanceResponse(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[InstanceId] = None


class ResourceArnOrId(RootModel[constr(min_length=1, max_length=250)]):
    root: constr(min_length=1, max_length=250)


class ResourceConflictException(RootModel[Any]):
    root: Any


class ResourceInUseException(RootModel[Any]):
    root: Any


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class ResourceNotReadyException(RootModel[Any]):
    root: Any


class ResumeContactRecordingRequest(BaseModel):
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InitialContactId: ContactId
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')


class ResumeContactRecordingResponse(BaseModel):
    pass


class RoutingProfileDescription(RootModel[constr(min_length=1, max_length=250)]):
    root: constr(min_length=1, max_length=250)


class RoutingProfileId(RootModel[str]):
    root: str


class RoutingProfileName(RootModel[constr(min_length=1, max_length=127)]):
    root: constr(min_length=1, max_length=127)


class RoutingProfileQueueConfigSummary(BaseModel):
    Channel_1: Channel = Field(..., alias='Channel')
    Delay_1: Delay = Field(..., alias='Delay')
    Priority_1: Priority = Field(..., alias='Priority')
    QueueArn: ARN
    QueueId_1: QueueId = Field(..., alias='QueueId')
    QueueName_1: QueueName = Field(..., alias='QueueName')


class RoutingProfileQueueConfigSummaryList(
    RootModel[List[RoutingProfileQueueConfigSummary]]
):
    root: List[RoutingProfileQueueConfigSummary]


class RoutingProfileQueueReference(BaseModel):
    Channel_1: Channel = Field(..., alias='Channel')
    QueueId_1: QueueId = Field(..., alias='QueueId')


class RoutingProfileQueueReferenceList(RootModel[List[RoutingProfileQueueReference]]):
    root: List[RoutingProfileQueueReference]


class RoutingProfileReference(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[RoutingProfileId] = None


class RoutingProfileSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[RoutingProfileId] = None
    Name: Optional[RoutingProfileName] = None


class RoutingProfileSummaryList(RootModel[List[RoutingProfileSummary]]):
    root: List[RoutingProfileSummary]


class RoutingProfiles(RootModel[List[RoutingProfileId]]):
    root: List[RoutingProfileId] = Field(..., max_length=100, min_length=1)


class RuleFunction(RootModel[str]):
    root: str


class RuleId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class RuleName(
    RootModel[constr(pattern=r'^[0-9a-zA-Z._-]+', min_length=1, max_length=200)]
):
    root: constr(pattern=r'^[0-9a-zA-Z._-]+', min_length=1, max_length=200)


class RulePublishStatus(Enum):
    DRAFT = 'DRAFT'
    PUBLISHED = 'PUBLISHED'


class RuleTriggerEventSource(BaseModel):
    EventSourceName_1: EventSourceName = Field(..., alias='EventSourceName')
    IntegrationAssociationId_1: Optional[IntegrationAssociationId] = Field(
        None, alias='IntegrationAssociationId'
    )


class SearchAvailablePhoneNumbersRequest(BaseModel):
    MaxResults: Optional[MaxResult10] = None
    NextToken: Optional[LargeNextToken] = None
    PhoneNumberCountryCode_1: PhoneNumberCountryCode = Field(
        ..., alias='PhoneNumberCountryCode'
    )
    PhoneNumberPrefix_1: Optional[PhoneNumberPrefix] = Field(
        None, alias='PhoneNumberPrefix'
    )
    PhoneNumberType_1: PhoneNumberType = Field(..., alias='PhoneNumberType')
    TargetArn: ARN


class SearchableQueueType(Enum):
    STANDARD = 'STANDARD'


class SecurityProfileDescription(RootModel[constr(max_length=250)]):
    root: constr(max_length=250)


class SecurityProfileId(RootModel[str]):
    root: str


class SecurityProfileIds(RootModel[List[SecurityProfileId]]):
    root: List[SecurityProfileId] = Field(..., max_length=10, min_length=1)


class SecurityProfileName(RootModel[str]):
    root: str


class SecurityProfilePermission(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class SecurityProfilePolicyKey(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class SecurityProfilePolicyValue(RootModel[constr(max_length=256)]):
    root: constr(max_length=256)


class SecurityProfileSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[SecurityProfileId] = None
    Name: Optional[SecurityProfileName] = None


class SecurityProfileSummaryList(RootModel[List[SecurityProfileSummary]]):
    root: List[SecurityProfileSummary]


class SecurityToken(RootModel[SecretStr]):
    root: SecretStr


class ServiceQuotaExceededException(RootModel[Any]):
    root: Any


class SnapshotVersion(RootModel[str]):
    root: str


class SortOrder(Enum):
    ASCENDING = 'ASCENDING'
    DESCENDING = 'DESCENDING'


class SourceApplicationName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9_ -]+$', min_length=1, max_length=100)]
):
    root: constr(pattern=r'^[a-zA-Z0-9_ -]+$', min_length=1, max_length=100)


class SourceType(Enum):
    SALESFORCE = 'SALESFORCE'
    ZENDESK = 'ZENDESK'


class StartChatContactResponse(BaseModel):
    ContactId_1: Optional[ContactId] = Field(None, alias='ContactId')
    ContinuedFromContactId: Optional[ContactId] = None
    ParticipantId_1: Optional[ParticipantId] = Field(None, alias='ParticipantId')
    ParticipantToken_1: Optional[ParticipantToken] = Field(
        None, alias='ParticipantToken'
    )


class StartContactRecordingResponse(BaseModel):
    pass


class StartOutboundVoiceContactResponse(BaseModel):
    ContactId_1: Optional[ContactId] = Field(None, alias='ContactId')


class StartTaskContactResponse(BaseModel):
    ContactId_1: Optional[ContactId] = Field(None, alias='ContactId')


class Statistic(Enum):
    SUM = 'SUM'
    MAX = 'MAX'
    AVG = 'AVG'


class StopContactRecordingRequest(BaseModel):
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InitialContactId: ContactId
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')


class StopContactRecordingResponse(BaseModel):
    pass


class StopContactRequest(BaseModel):
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')


class StopContactResponse(BaseModel):
    pass


class StopContactStreamingResponse(BaseModel):
    pass


class StorageType(Enum):
    S3 = 'S3'
    KINESIS_VIDEO_STREAM = 'KINESIS_VIDEO_STREAM'
    KINESIS_STREAM = 'KINESIS_STREAM'
    KINESIS_FIREHOSE = 'KINESIS_FIREHOSE'


class StreamingId(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class String(RootModel[str]):
    root: str


class StringComparisonType(Enum):
    STARTS_WITH = 'STARTS_WITH'
    CONTAINS = 'CONTAINS'
    EXACT = 'EXACT'


class StringCondition(BaseModel):
    ComparisonType: Optional[StringComparisonType] = None
    FieldName: Optional[String] = None
    Value: Optional[String] = None


class StringReference(BaseModel):
    Name: Optional[ReferenceKey] = None
    Value: Optional[ReferenceValue] = None


class Subject(RootModel[constr(min_length=1, max_length=200)]):
    root: constr(min_length=1, max_length=200)


class SupportedMessagingContentType(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class SupportedMessagingContentTypes(RootModel[List[SupportedMessagingContentType]]):
    root: List[SupportedMessagingContentType]


class SuspendContactRecordingRequest(BaseModel):
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InitialContactId: ContactId
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')


class SuspendContactRecordingResponse(BaseModel):
    pass


class TagCondition(BaseModel):
    TagKey: Optional[String] = None
    TagValue: Optional[String] = None


class TagKey(
    RootModel[
        constr(pattern=r'^(?!aws:)[a-zA-Z+-=._:/]+$', min_length=1, max_length=128)
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'^(?!aws:)[a-zA-Z+-=._:/]+$', min_length=1, max_length=128)


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class TagRestrictedResourceName(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class TagValue(RootModel[constr(max_length=256)]):
    root: constr(max_length=256)


class TaskDescriptionExpression(RootModel[constr(min_length=0, max_length=4096)]):
    root: constr(min_length=0, max_length=4096)


class TaskNameExpression(RootModel[constr(min_length=1, max_length=512)]):
    root: constr(min_length=1, max_length=512)


class TaskTemplateArn(RootModel[constr(min_length=1, max_length=500)]):
    root: constr(min_length=1, max_length=500)


class TaskTemplateDescription(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class TaskTemplateFieldDescription(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class TaskTemplateFieldName(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class TaskTemplateFieldType(Enum):
    NAME = 'NAME'
    DESCRIPTION = 'DESCRIPTION'
    SCHEDULED_TIME = 'SCHEDULED_TIME'
    QUICK_CONNECT = 'QUICK_CONNECT'
    URL = 'URL'
    NUMBER = 'NUMBER'
    TEXT = 'TEXT'
    TEXT_AREA = 'TEXT_AREA'
    DATE_TIME = 'DATE_TIME'
    BOOLEAN = 'BOOLEAN'
    SINGLE_SELECT = 'SINGLE_SELECT'
    EMAIL = 'EMAIL'


class TaskTemplateFieldValue(RootModel[constr(min_length=0, max_length=4096)]):
    root: constr(min_length=0, max_length=4096)


class TaskTemplateId(RootModel[constr(min_length=1, max_length=500)]):
    root: constr(min_length=1, max_length=500)


class TaskTemplateName(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class TaskTemplateSingleSelectOption(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class TaskTemplateStatus(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'


class ThresholdValue(RootModel[float]):
    root: float


class ThrottlingException(RootModel[Any]):
    root: Any


class TimeZone(RootModel[str]):
    root: str


class TimerEligibleParticipantRoles(Enum):
    CUSTOMER = 'CUSTOMER'
    AGENT = 'AGENT'


class Timestamp(RootModel[datetime]):
    root: datetime


class TrafficDistributionGroupArn(
    RootModel[
        constr(
            pattern=r'^arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
        )
    ]
):
    root: constr(
        pattern=r'^arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
    )


class TrafficDistributionGroupId(
    RootModel[
        constr(
            pattern=r'^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
        )
    ]
):
    root: constr(
        pattern=r'^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
    )


class TrafficDistributionGroupIdOrArn(
    RootModel[
        constr(
            pattern=r'^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
        )
    ]
):
    root: constr(
        pattern=r'^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
    )


class TrafficDistributionGroupStatus(Enum):
    CREATION_IN_PROGRESS = 'CREATION_IN_PROGRESS'
    ACTIVE = 'ACTIVE'
    CREATION_FAILED = 'CREATION_FAILED'
    PENDING_DELETION = 'PENDING_DELETION'
    DELETION_FAILED = 'DELETION_FAILED'
    UPDATE_IN_PROGRESS = 'UPDATE_IN_PROGRESS'


class TrafficDistributionGroupSummary(BaseModel):
    Arn: Optional[TrafficDistributionGroupArn] = None
    Id: Optional[TrafficDistributionGroupId] = None
    InstanceArn_1: Optional[InstanceArn] = Field(None, alias='InstanceArn')
    Name: Optional[Name128] = None
    Status: Optional[TrafficDistributionGroupStatus] = None


class TrafficDistributionGroupSummaryList(
    RootModel[List[TrafficDistributionGroupSummary]]
):
    root: List[TrafficDistributionGroupSummary] = Field(
        ..., max_length=10, min_length=0
    )


class TrafficType(Enum):
    GENERAL = 'GENERAL'
    CAMPAIGN = 'CAMPAIGN'


class TransferContactRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    ContactFlowId_1: ContactFlowId = Field(..., alias='ContactFlowId')
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    QueueId_1: Optional[QueueId] = Field(None, alias='QueueId')
    UserId: Optional[AgentResourceId] = None


class TransferContactResponse(BaseModel):
    ContactArn: Optional[ARN] = None
    ContactId_1: Optional[ContactId] = Field(None, alias='ContactId')


class URI(RootModel[constr(min_length=1, max_length=2000)]):
    root: constr(min_length=1, max_length=2000)


class Unit(Enum):
    SECONDS = 'SECONDS'
    COUNT = 'COUNT'
    PERCENT = 'PERCENT'


class UntagResourceRequest(BaseModel):
    pass


class UpdateAgentStatusDescription(RootModel[constr(min_length=0, max_length=250)]):
    root: constr(min_length=0, max_length=250)


class UpdateAgentStatusRequest(BaseModel):
    Description: Optional[UpdateAgentStatusDescription] = None
    DisplayOrder: Optional[AgentStatusOrderNumber] = None
    Name: Optional[AgentStatusName] = None
    ResetOrderNumber: Optional[Boolean] = None
    State: Optional[AgentStatusState] = None


class UpdateContactAttributesRequest(BaseModel):
    Attributes_1: Attributes = Field(..., alias='Attributes')
    InitialContactId: ContactId
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')


class UpdateContactAttributesResponse(BaseModel):
    pass


class UpdateContactFlowContentRequest(BaseModel):
    Content: ContactFlowContent


class UpdateContactFlowContentResponse(BaseModel):
    pass


class UpdateContactFlowMetadataRequest(BaseModel):
    ContactFlowState_1: Optional[ContactFlowState] = Field(
        None, alias='ContactFlowState'
    )
    Description: Optional[ContactFlowDescription] = None
    Name: Optional[ContactFlowName] = None


class UpdateContactFlowMetadataResponse(BaseModel):
    pass


class UpdateContactFlowModuleContentRequest(BaseModel):
    Content: ContactFlowModuleContent


class UpdateContactFlowModuleContentResponse(BaseModel):
    pass


class UpdateContactFlowModuleMetadataRequest(BaseModel):
    Description: Optional[ContactFlowModuleDescription] = None
    Name: Optional[ContactFlowModuleName] = None
    State: Optional[ContactFlowModuleState] = None


class UpdateContactFlowModuleMetadataResponse(BaseModel):
    pass


class UpdateContactFlowNameRequest(BaseModel):
    Description: Optional[ContactFlowDescription] = None
    Name: Optional[ContactFlowName] = None


class UpdateContactFlowNameResponse(BaseModel):
    pass


class UpdateContactResponse(BaseModel):
    pass


class UpdateContactScheduleRequest(BaseModel):
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    ScheduledTime: Timestamp


class UpdateContactScheduleResponse(BaseModel):
    pass


class UpdateHoursOfOperationDescription(
    RootModel[constr(min_length=0, max_length=250)]
):
    root: constr(min_length=0, max_length=250)


class UpdateInstanceAttributeRequest(BaseModel):
    Value: InstanceAttributeValue


class UpdateParticipantRoleConfigResponse(BaseModel):
    pass


class UpdatePhoneNumberRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    TargetArn: ARN


class UpdatePhoneNumberResponse(BaseModel):
    PhoneNumberArn: Optional[ARN] = None
    PhoneNumberId_1: Optional[PhoneNumberId] = Field(None, alias='PhoneNumberId')


class UpdateQueueHoursOfOperationRequest(BaseModel):
    HoursOfOperationId_1: HoursOfOperationId = Field(..., alias='HoursOfOperationId')


class UpdateQueueMaxContactsRequest(BaseModel):
    MaxContacts: Optional[QueueMaxContacts] = None


class UpdateQueueNameRequest(BaseModel):
    Description: Optional[QueueDescription] = None
    Name: Optional[CommonNameLength127] = None


class UpdateQueueStatusRequest(BaseModel):
    Status: QueueStatus


class UpdateQuickConnectDescription(RootModel[constr(min_length=0, max_length=250)]):
    root: constr(min_length=0, max_length=250)


class UpdateQuickConnectNameRequest(BaseModel):
    Description: Optional[UpdateQuickConnectDescription] = None
    Name: Optional[QuickConnectName] = None


class UpdateRoutingProfileDefaultOutboundQueueRequest(BaseModel):
    DefaultOutboundQueueId: QueueId


class UpdateRoutingProfileNameRequest(BaseModel):
    Description: Optional[RoutingProfileDescription] = None
    Name: Optional[RoutingProfileName] = None


class UpdateTrafficDistributionResponse(BaseModel):
    pass


class UpdateUserHierarchyGroupNameRequest(BaseModel):
    Name: HierarchyGroupName


class UpdateUserHierarchyRequest(BaseModel):
    HierarchyGroupId_1: Optional[HierarchyGroupId] = Field(
        None, alias='HierarchyGroupId'
    )


class UpdateUserHierarchyStructureRequest(BaseModel):
    HierarchyStructure: HierarchyStructureUpdate


class UpdateUserRoutingProfileRequest(BaseModel):
    RoutingProfileId_1: RoutingProfileId = Field(..., alias='RoutingProfileId')


class UpdateUserSecurityProfilesRequest(BaseModel):
    SecurityProfileIds_1: SecurityProfileIds = Field(..., alias='SecurityProfileIds')


class Url(RootModel[str]):
    root: str


class UrlReference(BaseModel):
    Name: Optional[ReferenceKey] = None
    Value: Optional[ReferenceValue] = None


class UseCaseId(RootModel[constr(min_length=1, max_length=200)]):
    root: constr(min_length=1, max_length=200)


class UseCaseType(Enum):
    RULES_EVALUATION = 'RULES_EVALUATION'
    CONNECT_CAMPAIGNS = 'CONNECT_CAMPAIGNS'


class UserDataHierarchyGroups(RootModel[List[HierarchyGroupId]]):
    root: List[HierarchyGroupId] = Field(..., max_length=1, min_length=1)


class UserId(RootModel[str]):
    root: str


class UserIdList(RootModel[List[UserId]]):
    root: List[UserId]


class UserIdentityInfo(BaseModel):
    Email_1: Optional[Email] = Field(None, alias='Email')
    FirstName: Optional[AgentFirstName] = None
    LastName: Optional[AgentLastName] = None
    Mobile: Optional[PhoneNumber] = None
    SecondaryEmail: Optional[Email] = None


class UserIdentityInfoLite(BaseModel):
    FirstName: Optional[AgentFirstName] = None
    LastName: Optional[AgentLastName] = None


class UserNotFoundException(RootModel[Any]):
    root: Any


class UserPhoneConfig(BaseModel):
    AfterContactWorkTimeLimit_1: Optional[AfterContactWorkTimeLimit] = Field(
        None, alias='AfterContactWorkTimeLimit'
    )
    AutoAccept_1: Optional[AutoAccept] = Field(None, alias='AutoAccept')
    DeskPhoneNumber: Optional[PhoneNumber] = None
    PhoneType_1: PhoneType = Field(..., alias='PhoneType')


class UserQuickConnectConfig(BaseModel):
    ContactFlowId_1: ContactFlowId = Field(..., alias='ContactFlowId')
    UserId_1: UserId = Field(..., alias='UserId')


class UserReference(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[UserId] = None


class UserSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[UserId] = None
    Username: Optional[AgentUsername] = None


class UserSummaryList(RootModel[List[UserSummary]]):
    root: List[UserSummary]


class UserTagMap(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class Value(RootModel[float]):
    root: float


class VocabularyContent(RootModel[constr(min_length=1, max_length=60000)]):
    root: constr(min_length=1, max_length=60000)


class VocabularyFailureReason(RootModel[str]):
    root: str


class VocabularyId(RootModel[constr(min_length=1, max_length=500)]):
    root: constr(min_length=1, max_length=500)


class VocabularyLanguageCode(Enum):
    ar_AE = 'ar-AE'
    de_CH = 'de-CH'
    de_DE = 'de-DE'
    en_AB = 'en-AB'
    en_AU = 'en-AU'
    en_GB = 'en-GB'
    en_IE = 'en-IE'
    en_IN = 'en-IN'
    en_US = 'en-US'
    en_WL = 'en-WL'
    es_ES = 'es-ES'
    es_US = 'es-US'
    fr_CA = 'fr-CA'
    fr_FR = 'fr-FR'
    hi_IN = 'hi-IN'
    it_IT = 'it-IT'
    ja_JP = 'ja-JP'
    ko_KR = 'ko-KR'
    pt_BR = 'pt-BR'
    pt_PT = 'pt-PT'
    zh_CN = 'zh-CN'
    en_NZ = 'en-NZ'
    en_ZA = 'en-ZA'


class VocabularyLastModifiedTime(RootModel[datetime]):
    root: datetime


class VocabularyName(
    RootModel[constr(pattern=r'^[0-9a-zA-Z._-]+', min_length=1, max_length=140)]
):
    root: constr(pattern=r'^[0-9a-zA-Z._-]+', min_length=1, max_length=140)


class VocabularyNextToken(
    RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=131070)]
):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=131070)


class VocabularyState(Enum):
    CREATION_IN_PROGRESS = 'CREATION_IN_PROGRESS'
    ACTIVE = 'ACTIVE'
    CREATION_FAILED = 'CREATION_FAILED'
    DELETE_IN_PROGRESS = 'DELETE_IN_PROGRESS'


class VocabularySummary(BaseModel):
    Arn: ARN
    FailureReason: Optional[VocabularyFailureReason] = None
    Id: VocabularyId
    LanguageCode: VocabularyLanguageCode
    LastModifiedTime: VocabularyLastModifiedTime
    Name: VocabularyName
    State: VocabularyState


class VocabularySummaryList(RootModel[List[VocabularySummary]]):
    root: List[VocabularySummary]


class VoiceRecordingTrack(Enum):
    FROM_AGENT = 'FROM_AGENT'
    TO_AGENT = 'TO_AGENT'
    ALL = 'ALL'


class WisdomInfo(BaseModel):
    SessionArn: Optional[ARN] = None


class State(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class AgentStatusInstanceIdPutRequest(BaseModel):
    Description: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='The description of the status.'
    )
    DisplayOrder: Optional[conint(ge=1, le=50)] = Field(
        None, description='The display order of the status.'
    )
    Name: constr(min_length=1, max_length=127) = Field(
        ..., description='The name of the status.'
    )
    State_1: State = Field(..., alias='State', description='The state of the status.')
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class AgentStatusInstanceIdAgentStatusIdPostRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=250)] = Field(
        None, description='The description of the agent status.'
    )
    DisplayOrder: Optional[conint(ge=1, le=50)] = Field(
        None, description='The display order of the agent status.'
    )
    Name: Optional[constr(min_length=1, max_length=127)] = Field(
        None, description='The name of the agent status.'
    )
    ResetOrderNumber: Optional[bool] = Field(
        None, description='A number indicating the reset order of the agent status.'
    )
    State_1: Optional[State] = Field(
        None, alias='State', description='The state of the agent status.'
    )


class State2(Enum):
    ACTIVE = 'ACTIVE'
    ARCHIVED = 'ARCHIVED'


class ContactFlowModulesInstanceIdPutRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    Content: constr(min_length=1, max_length=256000) = Field(
        ..., description='The content of the flow module.'
    )
    Description: Optional[constr(pattern=r'.*\S.*', min_length=0, max_length=500)] = (
        Field(None, description='The description of the flow module. ')
    )
    Name: constr(pattern=r'.*\S.*', min_length=1, max_length=127) = Field(
        ..., description='The name of the flow module.'
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class ContactFlowModulesInstanceIdContactFlowModuleIdContentPostRequest(BaseModel):
    Content: constr(min_length=1, max_length=256000) = Field(
        ..., description='The content of the flow module.'
    )


class ContactFlowModulesInstanceIdContactFlowModuleIdMetadataPostRequest(BaseModel):
    Description: Optional[constr(pattern=r'.*\S.*', min_length=0, max_length=500)] = (
        Field(None, description='The description of the flow module.')
    )
    Name: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=127)] = Field(
        None, description='The name of the flow module.'
    )
    State: Optional[State2] = Field(None, description='The state of flow module.')


class Type(Enum):
    CONTACT_FLOW = 'CONTACT_FLOW'
    CUSTOMER_QUEUE = 'CUSTOMER_QUEUE'
    CUSTOMER_HOLD = 'CUSTOMER_HOLD'
    CUSTOMER_WHISPER = 'CUSTOMER_WHISPER'
    AGENT_HOLD = 'AGENT_HOLD'
    AGENT_WHISPER = 'AGENT_WHISPER'
    OUTBOUND_WHISPER = 'OUTBOUND_WHISPER'
    AGENT_TRANSFER = 'AGENT_TRANSFER'
    QUEUE_TRANSFER = 'QUEUE_TRANSFER'


class ContactFlowsInstanceIdPutRequest(BaseModel):
    Content: str = Field(..., description='The content of the flow. ')
    Description: Optional[str] = Field(
        None, description='The description of the flow. '
    )
    Name: constr(min_length=1) = Field(..., description='The name of the flow.')
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )
    Type_1: Type = Field(
        ...,
        alias='Type',
        description='The type of the flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.',
    )


class ContactFlowsInstanceIdContactFlowIdContentPostRequest(BaseModel):
    Content: str = Field(
        ...,
        description='The JSON string that represents flow\'s content. For an example, see <a href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example contact flow in Amazon Connect Flow language</a>. ',
    )


class ContactFlowsInstanceIdContactFlowIdMetadataPostRequest(BaseModel):
    ContactFlowState_1: Optional[ContactFlowState] = Field(
        None, alias='ContactFlowState', description='The state of flow.'
    )
    Description: Optional[str] = Field(None, description='The description of the flow.')
    Name: Optional[constr(min_length=1)] = Field(
        None, description='The name of the flow.'
    )


class ContactFlowsInstanceIdContactFlowIdNamePostRequest(BaseModel):
    Description: Optional[str] = Field(None, description='The description of the flow.')
    Name: Optional[constr(min_length=1)] = Field(
        None, description='The name of the flow.'
    )


class ContactAttributesPostRequest(BaseModel):
    Attributes: Dict[str, AttributeValue] = Field(
        ...,
        description='<p>The Amazon Connect attributes. These attributes can be accessed in flows just like any other contact attributes.</p> <p>You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>',
    )
    InitialContactId: constr(min_length=1, max_length=256) = Field(
        ...,
        description='The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )


class InitialMessage(BaseModel):
    Content: Optional[ChatContent] = None
    ContentType: Optional[ChatContentType] = None


class ParticipantDetails1(BaseModel):
    DisplayName_1: Optional[DisplayName] = Field(None, alias='DisplayName')


class PersistentChat(BaseModel):
    RehydrationType_1: Optional[RehydrationType] = Field(None, alias='RehydrationType')
    SourceContactId: Optional[ContactId] = None


class ContactChatPutRequest(BaseModel):
    Attributes: Optional[Dict[str, AttributeValue]] = Field(
        None,
        description='<p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes. </p> <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>',
    )
    ChatDurationInMinutes: Optional[conint(ge=60, le=10080)] = Field(
        None,
        description='The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minimum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).',
    )
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    ContactFlowId: constr(max_length=500) = Field(
        ...,
        description='<p>The identifier of the flow for initiating the chat. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p> <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>',
    )
    InitialMessage_1: Optional[InitialMessage] = Field(
        None, alias='InitialMessage', description='A chat message.'
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    ParticipantDetails: ParticipantDetails1 = Field(
        ..., description="The customer's details."
    )
    PersistentChat_1: Optional[PersistentChat] = Field(
        None,
        alias='PersistentChat',
        description='Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.',
    )
    RelatedContactId: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description='<p>The unique identifier for an Amazon Connect contact. This identifier is related to the chat starting.</p> <note> <p>You cannot provide data for both RelatedContactId and PersistentChat. </p> </note>',
    )
    SupportedMessagingContentTypes: Optional[List[SupportedMessagingContentType]] = (
        Field(
            None,
            description='<p>The supported chat message content types. Supported types are <code>text/plain</code>, <code>text/markdown</code>, <code>application/json</code>, <code>application/vnd.amazonaws.connect.message.interactive</code>, and <code>application/vnd.amazonaws.connect.message.interactive.response</code>. </p> <p>Content types must always contain <code>text/plain</code>. You can then put any other supported type in the list. For example, all the following lists are valid because they contain <code>text/plain</code>: <code>[text/plain, text/markdown, application/json]</code>, <code>[text/markdown, text/plain]</code>, <code>[text/plain, application/json, application/vnd.amazonaws.connect.message.interactive.response]</code>. </p> <note> <p>The type <code>application/vnd.amazonaws.connect.message.interactive</code> is required to use the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/show-view-block.html">Show view</a> flow block.</p> </note>',
        )
    )


class ParticipantDetails2(BaseModel):
    DisplayName_1: Optional[DisplayName] = Field(None, alias='DisplayName')
    ParticipantRole_1: Optional[ParticipantRole] = Field(None, alias='ParticipantRole')


class ContactCreateParticipantPostRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    ContactId: constr(min_length=1, max_length=256) = Field(
        ...,
        description='The identifier of the contact in this instance of Amazon Connect. Only contacts in the CHAT channel are supported.',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance. ',
    )
    ParticipantDetails: ParticipantDetails2 = Field(
        ..., description='The details to add for the participant.'
    )


class ContactMonitorPostRequest(BaseModel):
    AllowedMonitorCapabilities: Optional[List[MonitorCapability]] = Field(
        None,
        description='Specify which monitoring actions the user is allowed to take. For example, whether the user is allowed to escalate from silent monitoring to barge.',
        max_length=2,
    )
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    ContactId: constr(min_length=1, max_length=256) = Field(
        ..., description='The identifier of the contact.'
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.',
    )
    UserId: constr(min_length=1, max_length=256) = Field(
        ..., description='The identifier of the user account.'
    )


class AnswerMachineDetectionConfig(BaseModel):
    AwaitAnswerMachinePrompt: Optional[Boolean] = None
    EnableAnswerMachineDetection: Optional[Boolean] = None


class ContactOutboundVoicePutRequest(BaseModel):
    AnswerMachineDetectionConfig_1: Optional[AnswerMachineDetectionConfig] = Field(
        None,
        alias='AnswerMachineDetectionConfig',
        description='Configuration of the answering machine detection.',
    )
    Attributes: Optional[Dict[str, AttributeValue]] = Field(
        None,
        description='<p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p> <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>',
    )
    CampaignId: Optional[constr(min_length=1, max_length=100)] = Field(
        None, description='The campaign identifier of the outbound communication.'
    )
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned. ',
    )
    ContactFlowId: constr(max_length=500) = Field(
        ...,
        description='<p>The identifier of the flow for the outbound call. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p> <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>',
    )
    DestinationPhoneNumber: constr(pattern=r'\\+[1-9]\\d{1,14}$') = Field(
        ..., description='The phone number of the customer, in E.164 format.'
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    QueueId: Optional[str] = Field(
        None,
        description='The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the flow is used. If you do not specify a queue, you must specify a source phone number.',
    )
    SourcePhoneNumber: Optional[constr(pattern=r'\\+[1-9]\\d{1,14}$')] = Field(
        None,
        description='The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.',
    )
    TrafficType_1: Optional[TrafficType] = Field(
        None,
        alias='TrafficType',
        description='Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is <code>GENERAL</code>. Use <code>CAMPAIGN</code> if <code>EnableAnswerMachineDetection</code> is set to <code>true</code>. For all other cases, use <code>GENERAL</code>. ',
    )


class ContactResumeRecordingPostRequest(BaseModel):
    ContactId: constr(min_length=1, max_length=256) = Field(
        ..., description='The identifier of the contact.'
    )
    InitialContactId: constr(min_length=1, max_length=256) = Field(
        ...,
        description='The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )


class ContactSchedulePostRequest(BaseModel):
    ContactId: constr(min_length=1, max_length=256) = Field(
        ..., description='The identifier of the contact.'
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    ScheduledTime: datetime = Field(
        ...,
        description='The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. ',
    )


class VoiceRecordingConfiguration(BaseModel):
    VoiceRecordingTrack_1: Optional[VoiceRecordingTrack] = Field(
        None, alias='VoiceRecordingTrack'
    )


class ContactStartRecordingPostRequest(BaseModel):
    ContactId: constr(min_length=1, max_length=256) = Field(
        ..., description='The identifier of the contact.'
    )
    InitialContactId: constr(min_length=1, max_length=256) = Field(
        ...,
        description='The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    VoiceRecordingConfiguration_1: VoiceRecordingConfiguration = Field(
        ...,
        alias='VoiceRecordingConfiguration',
        description='Contains information about the recording configuration settings.',
    )


class ChatStreamingConfiguration1(BaseModel):
    StreamingEndpointArn: Optional[ChatStreamingEndpointARN] = None


class ContactStartStreamingPostRequest(BaseModel):
    ChatStreamingConfiguration: ChatStreamingConfiguration1 = Field(
        ...,
        description='The streaming configuration, such as the Amazon SNS streaming endpoint.',
    )
    ClientToken: constr(max_length=500) = Field(
        ...,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    ContactId: constr(min_length=1, max_length=256) = Field(
        ...,
        description='The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )


class ContactStopPostRequest(BaseModel):
    ContactId: constr(min_length=1, max_length=256) = Field(
        ..., description='The ID of the contact.'
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )


class ContactStopRecordingPostRequest(BaseModel):
    ContactId: constr(min_length=1, max_length=256) = Field(
        ..., description='The identifier of the contact.'
    )
    InitialContactId: constr(min_length=1, max_length=256) = Field(
        ...,
        description='The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )


class ContactStopStreamingPostRequest(BaseModel):
    ContactId: constr(min_length=1, max_length=256) = Field(
        ...,
        description='The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    StreamingId: constr(min_length=1, max_length=100) = Field(
        ..., description='The identifier of the streaming configuration enabled. '
    )


class ContactSuspendRecordingPostRequest(BaseModel):
    ContactId: constr(min_length=1, max_length=256) = Field(
        ..., description='The identifier of the contact.'
    )
    InitialContactId: constr(min_length=1, max_length=256) = Field(
        ...,
        description='The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )


class ContactTransferPostRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    ContactFlowId: constr(max_length=500) = Field(
        ..., description='The identifier of the flow.'
    )
    ContactId: constr(min_length=1, max_length=256) = Field(
        ...,
        description='The identifier of the contact in this instance of Amazon Connect. ',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    QueueId: Optional[str] = Field(None, description='The identifier for the queue.')
    UserId: Optional[constr(min_length=1, max_length=256)] = Field(
        None, description='The identifier for the user.'
    )


class LanguageCode(Enum):
    ar_AE = 'ar-AE'
    de_CH = 'de-CH'
    de_DE = 'de-DE'
    en_AB = 'en-AB'
    en_AU = 'en-AU'
    en_GB = 'en-GB'
    en_IE = 'en-IE'
    en_IN = 'en-IN'
    en_US = 'en-US'
    en_WL = 'en-WL'
    es_ES = 'es-ES'
    es_US = 'es-US'
    fr_CA = 'fr-CA'
    fr_FR = 'fr-FR'
    hi_IN = 'hi-IN'
    it_IT = 'it-IT'
    ja_JP = 'ja-JP'
    ko_KR = 'ko-KR'
    pt_BR = 'pt-BR'
    pt_PT = 'pt-PT'
    zh_CN = 'zh-CN'
    en_NZ = 'en-NZ'
    en_ZA = 'en-ZA'


class DefaultVocabularySummaryInstanceIdPostRequest(BaseModel):
    LanguageCode_1: Optional[LanguageCode] = Field(
        None,
        alias='LanguageCode',
        description='The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> ',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=131070)] = (
        Field(
            None,
            description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
        )
    )


class DefaultVocabularyInstanceIdLanguageCodePutRequest(BaseModel):
    VocabularyId: Optional[constr(min_length=1, max_length=500)] = Field(
        None,
        description='The identifier of the custom vocabulary. If this is empty, the default is set to none.',
    )


class IdentityManagementType(Enum):
    SAML = 'SAML'
    CONNECT_MANAGED = 'CONNECT_MANAGED'
    EXISTING_DIRECTORY = 'EXISTING_DIRECTORY'


class InstancePutRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None, description='The idempotency token.'
    )
    DirectoryId: Optional[
        constr(pattern=r'^d-[0-9a-f]{10}$', min_length=12, max_length=12)
    ] = Field(None, description='The identifier for the directory.')
    IdentityManagementType_1: IdentityManagementType = Field(
        ...,
        alias='IdentityManagementType',
        description='The type of identity management for your Amazon Connect users.',
    )
    InboundCallsEnabled: bool = Field(
        ..., description='Your contact center handles incoming contacts.'
    )
    InstanceAlias: Optional[SecretStr] = Field(
        None, description='The name for your instance.'
    )
    OutboundCallsEnabled: bool = Field(
        ..., description='Your contact center allows outbound calls.'
    )


class InstanceInstanceIdApprovedOriginPutRequest(BaseModel):
    Origin: constr(max_length=267) = Field(
        ..., description='The domain to add to your allow list.'
    )


class AttributeType(Enum):
    INBOUND_CALLS = 'INBOUND_CALLS'
    OUTBOUND_CALLS = 'OUTBOUND_CALLS'
    CONTACTFLOW_LOGS = 'CONTACTFLOW_LOGS'
    CONTACT_LENS = 'CONTACT_LENS'
    AUTO_RESOLVE_BEST_VOICES = 'AUTO_RESOLVE_BEST_VOICES'
    USE_CUSTOM_TTS_VOICES = 'USE_CUSTOM_TTS_VOICES'
    EARLY_MEDIA = 'EARLY_MEDIA'
    MULTI_PARTY_CONFERENCE = 'MULTI_PARTY_CONFERENCE'
    HIGH_VOLUME_OUTBOUND = 'HIGH_VOLUME_OUTBOUND'
    ENHANCED_CONTACT_MONITORING = 'ENHANCED_CONTACT_MONITORING'


class InstanceInstanceIdAttributeAttributeTypePostRequest(BaseModel):
    Value: constr(min_length=1, max_length=100) = Field(
        ..., description='The value for the attribute. Maximum character limit is 100. '
    )


class LexBot1(BaseModel):
    LexRegion_1: Optional[LexRegion] = Field(None, alias='LexRegion')
    Name: Optional[BotName] = None


class InstanceInstanceIdBotPostRequest(BaseModel):
    LexBot: Optional[LexBot1] = Field(
        None, description='Configuration information of an Amazon Lex bot.'
    )
    LexV2Bot_1: Optional[LexV2Bot] = Field(
        None,
        alias='LexV2Bot',
        description='Configuration information of an Amazon Lex V2 bot.',
    )


class InstanceInstanceIdBotPutRequest(BaseModel):
    LexBot: Optional[LexBot1] = Field(
        None, description='Configuration information of an Amazon Lex bot.'
    )
    LexV2Bot_1: Optional[LexV2Bot] = Field(
        None,
        alias='LexV2Bot',
        description='Configuration information of an Amazon Lex V2 bot.',
    )


class InstanceInstanceIdIntegrationAssociationsPutRequest(BaseModel):
    IntegrationArn: str = Field(
        ...,
        description='<p>The Amazon Resource Name (ARN) of the integration.</p> <note> <p>When integrating with Amazon Pinpoint, the Amazon Connect and Amazon Pinpoint instances must be in the same account.</p> </note>',
    )
    IntegrationType_1: IntegrationType = Field(
        ...,
        alias='IntegrationType',
        description='The type of information to be ingested.',
    )
    SourceApplicationName: Optional[
        constr(pattern=r'^[a-zA-Z0-9_ -]+$', min_length=1, max_length=100)
    ] = Field(
        None,
        description='The name of the external application. This field is only required for the EVENT integration type.',
    )
    SourceApplicationUrl: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='The URL for the external application. This field is only required for the EVENT integration type.',
    )
    SourceType_1: Optional[SourceType] = Field(
        None,
        alias='SourceType',
        description='The type of the data source. This field is only required for the EVENT integration type.',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class InstanceInstanceIdIntegrationAssociationsIntegrationAssociationIdUseCasesPutRequest(
    BaseModel
):
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )
    UseCaseType_1: UseCaseType = Field(
        ...,
        alias='UseCaseType',
        description='The type of use case to associate to the integration association. Each integration association can have only one of each use case type.',
    )


class InstanceInstanceIdLambdaFunctionPutRequest(BaseModel):
    FunctionArn: constr(min_length=1, max_length=140) = Field(
        ...,
        description='The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.',
    )


class InstanceInstanceIdLexBotPutRequest(BaseModel):
    LexBot: LexBot1 = Field(
        ..., description='Configuration information of an Amazon Lex bot.'
    )


class InstanceInstanceIdReplicatePostRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    ReplicaAlias: SecretStr = Field(
        ...,
        description='The alias for the replicated instance. The <code>ReplicaAlias</code> must be unique.',
    )
    ReplicaRegion: constr(
        pattern=r'[a-z]{2}(-[a-z]+){1,2}(-[0-9])?', min_length=8, max_length=31
    ) = Field(
        ...,
        description='The Amazon Web Services Region where to replicate the Amazon Connect instance.',
    )


class InstanceInstanceIdSecurityKeyPutRequest(BaseModel):
    Key: constr(min_length=1, max_length=1024) = Field(
        ..., description='A valid security key in PEM format.'
    )


class ResourceType(Enum):
    CHAT_TRANSCRIPTS = 'CHAT_TRANSCRIPTS'
    CALL_RECORDINGS = 'CALL_RECORDINGS'
    SCHEDULED_REPORTS = 'SCHEDULED_REPORTS'
    MEDIA_STREAMS = 'MEDIA_STREAMS'
    CONTACT_TRACE_RECORDS = 'CONTACT_TRACE_RECORDS'
    AGENT_EVENTS = 'AGENT_EVENTS'
    REAL_TIME_CONTACT_ANALYSIS_SEGMENTS = 'REAL_TIME_CONTACT_ANALYSIS_SEGMENTS'
    ATTACHMENTS = 'ATTACHMENTS'
    CONTACT_EVALUATIONS = 'CONTACT_EVALUATIONS'


class Status(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'


class Filters(BaseModel):
    Channels_1: Optional[Channels] = Field(None, alias='Channels')
    Queues_1: Optional[Queues] = Field(None, alias='Queues')
    RoutingProfiles_1: Optional[RoutingProfiles] = Field(None, alias='RoutingProfiles')


class PhoneNumberClaimPostRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='<p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p> <p>Pattern: <code>^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$</code> </p>',
    )
    PhoneNumber: constr(pattern=r'\\+[1-9]\\d{1,14}$') = Field(
        ...,
        description='The phone number you want to claim. Phone numbers are formatted <code>[+] [country code] [subscriber number including area code]</code>.',
    )
    PhoneNumberDescription: Optional[
        constr(pattern=r'^[\W\S_]*', min_length=0, max_length=500)
    ] = Field(None, description='The description of the phone number.')
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )
    TargetArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.',
    )


class PhoneNumberListPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=1000)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[constr(min_length=1, max_length=100000)] = Field(
        None,
        description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
    )
    PhoneNumberCountryCodes: Optional[List[PhoneNumberCountryCode]] = Field(
        None, description='The ISO country code.', max_length=10
    )
    PhoneNumberPrefix: Optional[constr(pattern=r'\\+?[0-9]{1,11}')] = Field(
        None,
        description='The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.',
    )
    PhoneNumberTypes: Optional[List[PhoneNumberType]] = Field(
        None, description='The type of phone number.', max_length=2
    )
    TargetArn: Optional[str] = Field(
        None,
        description='The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to. If <code>TargetArn</code> input is not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same Amazon Web Services Region as the request.',
    )


class PhoneNumberSearchAvailablePostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=10)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[constr(min_length=1, max_length=100000)] = Field(
        None,
        description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
    )
    PhoneNumberCountryCode_1: PhoneNumberCountryCode = Field(
        ..., alias='PhoneNumberCountryCode', description='The ISO country code.'
    )
    PhoneNumberPrefix: Optional[constr(pattern=r'\\+?[0-9]{1,11}')] = Field(
        None,
        description='The prefix of the phone number. If provided, it must contain <code>+</code> as part of the country code.',
    )
    PhoneNumberType_1: PhoneNumberType = Field(
        ..., alias='PhoneNumberType', description='The type of phone number.'
    )
    TargetArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.',
    )


class PhoneNumberPhoneNumberIdPutRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    TargetArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.',
    )


class PhoneNumberPhoneNumberIdContactFlowPutRequest(BaseModel):
    ContactFlowId: constr(max_length=500) = Field(
        ..., description='The identifier of the flow.'
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )


class OutboundCallerConfig(BaseModel):
    OutboundCallerIdName_1: Optional[OutboundCallerIdName] = Field(
        None, alias='OutboundCallerIdName'
    )
    OutboundCallerIdNumberId: Optional[PhoneNumberId] = None
    OutboundFlowId: Optional[ContactFlowId] = None


class QueuesInstanceIdPutRequest(BaseModel):
    Description: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='The description of the queue.'
    )
    HoursOfOperationId: str = Field(
        ..., description='The identifier for the hours of operation.'
    )
    MaxContacts: Optional[conint(ge=0)] = Field(
        None,
        description='The maximum number of contacts that can be in the queue before it is considered full.',
    )
    Name: constr(min_length=1, max_length=127) = Field(
        ..., description='The name of the queue.'
    )
    OutboundCallerConfig_1: Optional[OutboundCallerConfig] = Field(
        None,
        alias='OutboundCallerConfig',
        description='The outbound caller ID name, number, and outbound whisper flow.',
    )
    QuickConnectIds: Optional[List[QuickConnectId]] = Field(
        None,
        description='The quick connects available to agents who are working the queue.',
        max_length=50,
        min_length=1,
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class QueuesInstanceIdQueueIdAssociateQuickConnectsPostRequest(BaseModel):
    QuickConnectIds: List[QuickConnectId] = Field(
        ...,
        description='The quick connects to associate with this queue.',
        max_length=50,
        min_length=1,
    )


class QueuesInstanceIdQueueIdDisassociateQuickConnectsPostRequest(BaseModel):
    QuickConnectIds: List[QuickConnectId] = Field(
        ...,
        description='The quick connects to disassociate from the queue.',
        max_length=50,
        min_length=1,
    )


class QueuesInstanceIdQueueIdHoursOfOperationPostRequest(BaseModel):
    HoursOfOperationId: str = Field(
        ..., description='The identifier for the hours of operation.'
    )


class QueuesInstanceIdQueueIdMaxContactsPostRequest(BaseModel):
    MaxContacts: Optional[conint(ge=0)] = Field(
        None,
        description='The maximum number of contacts that can be in the queue before it is considered full.',
    )


class QueuesInstanceIdQueueIdNamePostRequest(BaseModel):
    Description: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='The description of the queue.'
    )
    Name: Optional[constr(min_length=1, max_length=127)] = Field(
        None, description='The name of the queue.'
    )


class QueuesInstanceIdQueueIdOutboundCallerConfigPostRequest(BaseModel):
    OutboundCallerConfig_1: OutboundCallerConfig = Field(
        ...,
        alias='OutboundCallerConfig',
        description='The outbound caller ID name, number, and outbound whisper flow.',
    )


class Status4(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class QueuesInstanceIdQueueIdStatusPostRequest(BaseModel):
    Status: Status4 = Field(..., description='The status of the queue.')


class QuickConnectConfig1(BaseModel):
    PhoneConfig: Optional[PhoneNumberQuickConnectConfig] = None
    QueueConfig: Optional[QueueQuickConnectConfig] = None
    QuickConnectType_1: Optional[QuickConnectType] = Field(
        None, alias='QuickConnectType'
    )
    UserConfig: Optional[UserQuickConnectConfig] = None


class QuickConnectsInstanceIdPutRequest(BaseModel):
    Description: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='The description of the quick connect.'
    )
    Name: constr(min_length=1, max_length=127) = Field(
        ..., description='The name of the quick connect.'
    )
    QuickConnectConfig: QuickConnectConfig1 = Field(
        ..., description='Contains configuration settings for a quick connect.'
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class QuickConnectsInstanceIdQuickConnectIdConfigPostRequest(BaseModel):
    QuickConnectConfig: QuickConnectConfig1 = Field(
        ..., description='Contains configuration settings for a quick connect.'
    )


class QuickConnectsInstanceIdQuickConnectIdNamePostRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=250)] = Field(
        None, description='The description of the quick connect.'
    )
    Name: Optional[constr(min_length=1, max_length=127)] = Field(
        None, description='The name of the quick connect.'
    )


class RoutingProfilesInstanceIdRoutingProfileIdConcurrencyPostRequest(BaseModel):
    MediaConcurrencies: List[MediaConcurrency] = Field(
        ...,
        description='The channels that agents can handle in the Contact Control Panel (CCP).',
    )


class RoutingProfilesInstanceIdRoutingProfileIdDefaultOutboundQueuePostRequest(
    BaseModel
):
    DefaultOutboundQueueId: str = Field(
        ..., description='The identifier for the default outbound queue.'
    )


class RoutingProfilesInstanceIdRoutingProfileIdDisassociateQueuesPostRequest(BaseModel):
    QueueReferences: List[RoutingProfileQueueReference] = Field(
        ..., description='The queues to disassociate from this routing profile.'
    )


class RoutingProfilesInstanceIdRoutingProfileIdNamePostRequest(BaseModel):
    Description: Optional[constr(min_length=1, max_length=250)] = Field(
        None,
        description='The description of the routing profile. Must not be more than 250 characters.',
    )
    Name: Optional[constr(min_length=1, max_length=127)] = Field(
        None,
        description='The name of the routing profile. Must not be more than 127 characters.',
    )


class PublishStatus(Enum):
    DRAFT = 'DRAFT'
    PUBLISHED = 'PUBLISHED'


class TriggerEventSource(BaseModel):
    EventSourceName_1: Optional[EventSourceName] = Field(None, alias='EventSourceName')
    IntegrationAssociationId_1: Optional[IntegrationAssociationId] = Field(
        None, alias='IntegrationAssociationId'
    )


class SecurityProfilesInstanceIdPutRequest(BaseModel):
    AllowedAccessControlTags: Optional[Dict[str, SecurityProfilePolicyValue]] = Field(
        None,
        description='The list of tags that a security profile uses to restrict access to resources in Amazon Connect.',
    )
    Description: Optional[constr(max_length=250)] = Field(
        None, description='The description of the security profile.'
    )
    Permissions: Optional[List[SecurityProfilePermission]] = Field(
        None,
        description='Permissions assigned to the security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>. ',
        max_length=500,
    )
    SecurityProfileName: constr(
        pattern=r'^[ a-zA-Z0-9_@-]+$', min_length=1, max_length=127
    ) = Field(..., description='The name of the security profile.')
    TagRestrictedResources: Optional[List[TagRestrictedResourceName]] = Field(
        None,
        description='The list of resources that a security profile applies tag restrictions to in Amazon Connect. Following are acceptable ResourceNames: <code>User</code> | <code>SecurityProfile</code> | <code>Queue</code> | <code>RoutingProfile</code> ',
        max_length=10,
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class SecurityProfilesInstanceIdSecurityProfileIdPostRequest(BaseModel):
    AllowedAccessControlTags: Optional[Dict[str, SecurityProfilePolicyValue]] = Field(
        None,
        description='The list of tags that a security profile uses to restrict access to resources in Amazon Connect.',
    )
    Description: Optional[constr(max_length=250)] = Field(
        None, description='The description of the security profile.'
    )
    Permissions: Optional[List[SecurityProfilePermission]] = Field(
        None,
        description='The permissions granted to a security profile. For a list of valid permissions, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List of security profile permissions</a>.',
        max_length=500,
    )
    TagRestrictedResources: Optional[List[TagRestrictedResourceName]] = Field(
        None,
        description='The list of resources that a security profile applies tag restrictions to in Amazon Connect.',
        max_length=10,
    )


class TagsResourceArnPostRequest(BaseModel):
    tags: Dict[str, TagValue] = Field(
        ...,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class TagKeys(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class TrafficDistributionGroupPutRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    Description: Optional[
        constr(pattern=r'(^[\S].*[\S]$)|(^[\S]$)', min_length=1, max_length=250)
    ] = Field(None, description='A description for the traffic distribution group.')
    InstanceId: constr(
        pattern=r'^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$',
        min_length=1,
        max_length=250,
    ) = Field(
        ...,
        description='The identifier of the Amazon Connect instance that has been replicated. You can find the <code>instanceId</code> in the ARN of the instance.',
    )
    Name: constr(pattern=r'(^[\S].*[\S]$)|(^[\S]$)', min_length=1, max_length=128) = (
        Field(..., description='The name for the traffic distribution group. ')
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class UserHierarchyGroupsInstanceIdPutRequest(BaseModel):
    Name: str = Field(
        ...,
        description='The name of the user hierarchy group. Must not be more than 100 characters.',
    )
    ParentGroupId: Optional[str] = Field(
        None,
        description='The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class UserHierarchyGroupsInstanceIdHierarchyGroupIdNamePostRequest(BaseModel):
    Name: str = Field(
        ...,
        description='The name of the hierarchy group. Must not be more than 100 characters.',
    )


class HierarchyStructure1(BaseModel):
    LevelFive: Optional[HierarchyLevelUpdate] = None
    LevelFour: Optional[HierarchyLevelUpdate] = None
    LevelOne: Optional[HierarchyLevelUpdate] = None
    LevelThree: Optional[HierarchyLevelUpdate] = None
    LevelTwo: Optional[HierarchyLevelUpdate] = None


class UserHierarchyStructureInstanceIdPostRequest(BaseModel):
    HierarchyStructure: HierarchyStructure1 = Field(
        ..., description='Contains information about the level hierarchy to update.'
    )


class IdentityInfo(BaseModel):
    Email_1: Optional[Email] = Field(None, alias='Email')
    FirstName: Optional[AgentFirstName] = None
    LastName: Optional[AgentLastName] = None
    Mobile: Optional[PhoneNumber] = None
    SecondaryEmail: Optional[Email] = None


class PhoneConfig(BaseModel):
    AfterContactWorkTimeLimit_1: Optional[AfterContactWorkTimeLimit] = Field(
        None, alias='AfterContactWorkTimeLimit'
    )
    AutoAccept_1: Optional[AutoAccept] = Field(None, alias='AutoAccept')
    DeskPhoneNumber: Optional[PhoneNumber] = None
    PhoneType_1: Optional[PhoneType] = Field(None, alias='PhoneType')


class UsersInstanceIdPutRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    DirectoryUserId: Optional[str] = Field(
        None,
        description='<p>The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory.</p> <p>This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.</p>',
    )
    HierarchyGroupId: Optional[str] = Field(
        None, description='The identifier of the hierarchy group for the user.'
    )
    IdentityInfo_1: Optional[IdentityInfo] = Field(
        None,
        alias='IdentityInfo',
        description='Contains information about the identity of a user.',
    )
    Password: Optional[
        constr(pattern=r'/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d\S]{8,64}$/')
    ] = Field(
        None,
        description='The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.',
    )
    PhoneConfig_1: PhoneConfig = Field(
        ...,
        alias='PhoneConfig',
        description='Contains information about the phone configuration settings for a user.',
    )
    RoutingProfileId: str = Field(
        ..., description='The identifier of the routing profile for the user.'
    )
    SecurityProfileIds: List[SecurityProfileId] = Field(
        ...,
        description='The identifier of the security profile for the user.',
        max_length=10,
        min_length=1,
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )
    Username: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\\@]+.',
    )


class UsersInstanceIdUserIdContactPostRequest(BaseModel):
    ContactId: constr(min_length=1, max_length=256) = Field(
        ..., description='The identifier of the contact.'
    )


class UsersInstanceIdUserIdHierarchyPostRequest(BaseModel):
    HierarchyGroupId: Optional[str] = Field(
        None, description='The identifier of the hierarchy group.'
    )


class UsersInstanceIdUserIdIdentityInfoPostRequest(BaseModel):
    IdentityInfo_1: IdentityInfo = Field(
        ...,
        alias='IdentityInfo',
        description='Contains information about the identity of a user.',
    )


class UsersInstanceIdUserIdPhoneConfigPostRequest(BaseModel):
    PhoneConfig_1: PhoneConfig = Field(
        ...,
        alias='PhoneConfig',
        description='Contains information about the phone configuration settings for a user.',
    )


class UsersInstanceIdUserIdRoutingProfilePostRequest(BaseModel):
    RoutingProfileId: str = Field(
        ..., description='The identifier of the routing profile for the user.'
    )


class UsersInstanceIdUserIdSecurityProfilesPostRequest(BaseModel):
    SecurityProfileIds: List[SecurityProfileId] = Field(
        ...,
        description='The identifiers of the security profiles for the user.',
        max_length=10,
        min_length=1,
    )


class UsersInstanceIdUserIdStatusPutRequest(BaseModel):
    AgentStatusId: str = Field(..., description='The identifier of the agent status.')


class State5(Enum):
    CREATION_IN_PROGRESS = 'CREATION_IN_PROGRESS'
    ACTIVE = 'ACTIVE'
    CREATION_FAILED = 'CREATION_FAILED'
    DELETE_IN_PROGRESS = 'DELETE_IN_PROGRESS'


class VocabularySummaryInstanceIdPostRequest(BaseModel):
    LanguageCode_1: Optional[LanguageCode] = Field(
        None,
        alias='LanguageCode',
        description='The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> ',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NameStartsWith: Optional[
        constr(pattern=r'^[0-9a-zA-Z._-]+', min_length=1, max_length=140)
    ] = Field(None, description='The starting pattern of the name of the vocabulary.')
    NextToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=131070)] = (
        Field(
            None,
            description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
        )
    )
    State: Optional[State5] = Field(
        None, description='The current state of the custom vocabulary.'
    )


class VocabularyInstanceIdPostRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>. If a create request is received more than once with same client token, subsequent requests return the previous response without creating a vocabulary again.',
    )
    Content: constr(min_length=1, max_length=60000) = Field(
        ...,
        description='The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and <code>DisplayAs</code> fields. Separate the fields with TAB characters. The size limit is 50KB. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create a custom vocabulary using a table</a>.',
    )
    LanguageCode_1: LanguageCode = Field(
        ...,
        alias='LanguageCode',
        description='The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What is Amazon Transcribe?</a> ',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )
    VocabularyName: constr(
        pattern=r'^[0-9a-zA-Z._-]+', min_length=1, max_length=140
    ) = Field(..., description='A unique name of the custom vocabulary.')


class ActionSummary(BaseModel):
    ActionType_1: ActionType = Field(..., alias='ActionType')


class AgentContactReference(BaseModel):
    AgentContactState: Optional[ContactState] = None
    Channel_1: Optional[Channel] = Field(None, alias='Channel')
    ConnectedToAgentTimestamp: Optional[Timestamp] = None
    ContactId_1: Optional[ContactId] = Field(None, alias='ContactId')
    InitiationMethod: Optional[ContactInitiationMethod] = None
    Queue: Optional[QueueReference] = None
    StateStartTimestamp: Optional[Timestamp] = None


class AgentContactReferenceList(RootModel[List[AgentContactReference]]):
    root: List[AgentContactReference]


class AgentInfo(BaseModel):
    ConnectedToAgentTimestamp: Optional[Timestamp] = None
    Id: Optional[AgentResourceId] = None


class AgentStatusReference(BaseModel):
    StatusArn: Optional[ARN] = None
    StatusName: Optional[AgentStatusName] = None
    StatusStartTimestamp: Optional[Timestamp] = None


class AgentStatusSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[AgentStatusId] = None
    Name: Optional[AgentStatusName] = None
    Type: Optional[AgentStatusType] = None


class AgentStatusSummaryList(RootModel[List[AgentStatusSummary]]):
    root: List[AgentStatusSummary]


class AgentsMinOneMaxHundred(RootModel[List[UserId]]):
    root: List[UserId] = Field(..., max_length=100, min_length=1)


class AllowedAccessControlTags(
    RootModel[Optional[Dict[str, SecurityProfilePolicyValue]]]
):
    root: Optional[Dict[str, SecurityProfilePolicyValue]] = None


class AllowedMonitorCapabilities(RootModel[List[MonitorCapability]]):
    root: List[MonitorCapability] = Field(..., max_length=2)


class AssociateApprovedOriginRequest(BaseModel):
    Origin_1: Origin = Field(..., alias='Origin')


class AssociateDefaultVocabularyRequest(BaseModel):
    VocabularyId_1: Optional[VocabularyId] = Field(None, alias='VocabularyId')


class AssociateInstanceStorageConfigResponse(BaseModel):
    AssociationId_1: Optional[AssociationId] = Field(None, alias='AssociationId')


class AssociateLambdaFunctionRequest(BaseModel):
    FunctionArn_1: FunctionArn = Field(..., alias='FunctionArn')


class AssociatePhoneNumberContactFlowRequest(BaseModel):
    ContactFlowId_1: ContactFlowId = Field(..., alias='ContactFlowId')
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')


class AssociateQueueQuickConnectsRequest(BaseModel):
    QuickConnectIds: QuickConnectsList


class AssociateSecurityKeyRequest(BaseModel):
    Key: PEM


class AssociateSecurityKeyResponse(BaseModel):
    AssociationId_1: Optional[AssociationId] = Field(None, alias='AssociationId')


class AttachmentReference(BaseModel):
    Name: Optional[ReferenceKey] = None
    Status: Optional[ReferenceStatus] = None
    Value: Optional[ReferenceValue] = None


class Attribute(BaseModel):
    AttributeType: Optional[InstanceAttributeType] = None
    Value: Optional[InstanceAttributeValue] = None


class AttributesList(RootModel[List[Attribute]]):
    root: List[Attribute]


class AvailableNumberSummary(BaseModel):
    PhoneNumber_1: Optional[PhoneNumber] = Field(None, alias='PhoneNumber')
    PhoneNumberCountryCode_1: Optional[PhoneNumberCountryCode] = Field(
        None, alias='PhoneNumberCountryCode'
    )
    PhoneNumberType_1: Optional[PhoneNumberType] = Field(None, alias='PhoneNumberType')


class AvailableNumbersList(RootModel[List[AvailableNumberSummary]]):
    root: List[AvailableNumberSummary]


class ChannelToCountMap(RootModel[Optional[Dict[str, IntegerCount]]]):
    root: Optional[Dict[str, IntegerCount]] = None


class ChatStreamingConfiguration(BaseModel):
    StreamingEndpointArn: ChatStreamingEndpointARN


class ClaimPhoneNumberResponse(BaseModel):
    PhoneNumberArn: Optional[ARN] = None
    PhoneNumberId_1: Optional[PhoneNumberId] = Field(None, alias='PhoneNumberId')


class ContactFilter(BaseModel):
    ContactStates_1: Optional[ContactStates] = Field(None, alias='ContactStates')


class ContactFlowSummary(BaseModel):
    Arn: Optional[ARN] = None
    ContactFlowState_1: Optional[ContactFlowState] = Field(
        None, alias='ContactFlowState'
    )
    ContactFlowType_1: Optional[ContactFlowType] = Field(None, alias='ContactFlowType')
    Id: Optional[ContactFlowId] = None
    Name: Optional[ContactFlowName] = None


class ContactFlowSummaryList(RootModel[List[ContactFlowSummary]]):
    root: List[ContactFlowSummary]


class CreateHoursOfOperationResponse(BaseModel):
    HoursOfOperationArn: Optional[ARN] = None
    HoursOfOperationId_1: Optional[HoursOfOperationId] = Field(
        None, alias='HoursOfOperationId'
    )


class CreateInstanceRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    DirectoryId_1: Optional[DirectoryId] = Field(None, alias='DirectoryId')
    IdentityManagementType: DirectoryType
    InboundCallsEnabled_1: InboundCallsEnabled = Field(..., alias='InboundCallsEnabled')
    InstanceAlias: Optional[DirectoryAlias] = None
    OutboundCallsEnabled_1: OutboundCallsEnabled = Field(
        ..., alias='OutboundCallsEnabled'
    )


class CreateInstanceResponse(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[InstanceId] = None


class CreateIntegrationAssociationResponse(BaseModel):
    IntegrationAssociationArn: Optional[ARN] = None
    IntegrationAssociationId_1: Optional[IntegrationAssociationId] = Field(
        None, alias='IntegrationAssociationId'
    )


class CreateParticipantResponse(BaseModel):
    ParticipantCredentials: Optional[ParticipantTokenCredentials] = None
    ParticipantId_1: Optional[ParticipantId] = Field(None, alias='ParticipantId')


class CreateQueueResponse(BaseModel):
    QueueArn: Optional[ARN] = None
    QueueId_1: Optional[QueueId] = Field(None, alias='QueueId')


class CreateQuickConnectResponse(BaseModel):
    QuickConnectARN: Optional[ARN] = None
    QuickConnectId_1: Optional[QuickConnectId] = Field(None, alias='QuickConnectId')


class CreateRoutingProfileResponse(BaseModel):
    RoutingProfileArn: Optional[ARN] = None
    RoutingProfileId_1: Optional[RoutingProfileId] = Field(
        None, alias='RoutingProfileId'
    )


class CreateRuleResponse(BaseModel):
    RuleArn: ARN
    RuleId_1: RuleId = Field(..., alias='RuleId')


class CreateSecurityProfileResponse(BaseModel):
    SecurityProfileArn: Optional[ARN] = None
    SecurityProfileId_1: Optional[SecurityProfileId] = Field(
        None, alias='SecurityProfileId'
    )


class CreateTaskTemplateResponse(BaseModel):
    Arn: TaskTemplateArn
    Id: TaskTemplateId


class CreateTrafficDistributionGroupResponse(BaseModel):
    Arn: Optional[TrafficDistributionGroupArn] = None
    Id: Optional[TrafficDistributionGroupId] = None


class CreateUseCaseResponse(BaseModel):
    UseCaseArn: Optional[ARN] = None
    UseCaseId_1: Optional[UseCaseId] = Field(None, alias='UseCaseId')


class CreateUserHierarchyGroupResponse(BaseModel):
    HierarchyGroupArn: Optional[ARN] = None
    HierarchyGroupId_1: Optional[HierarchyGroupId] = Field(
        None, alias='HierarchyGroupId'
    )


class CreateUserResponse(BaseModel):
    UserArn: Optional[ARN] = None
    UserId_1: Optional[UserId] = Field(None, alias='UserId')


class CreateVocabularyResponse(BaseModel):
    State: VocabularyState
    VocabularyArn: ARN
    VocabularyId_1: VocabularyId = Field(..., alias='VocabularyId')


class Credentials(BaseModel):
    AccessToken: Optional[SecurityToken] = None
    AccessTokenExpiration: Optional[Timestamp] = None
    RefreshToken: Optional[SecurityToken] = None
    RefreshTokenExpiration: Optional[Timestamp] = None


class CurrentMetric(BaseModel):
    Name: Optional[CurrentMetricName] = None
    Unit_1: Optional[Unit] = Field(None, alias='Unit')


class CurrentMetricData(BaseModel):
    Metric: Optional[CurrentMetric] = None
    Value_1: Optional[Value] = Field(None, alias='Value')


class CurrentMetricDataCollections(RootModel[List[CurrentMetricData]]):
    root: List[CurrentMetricData]


class CurrentMetricSortCriteria(BaseModel):
    SortByMetric: Optional[CurrentMetricName] = None
    SortOrder_1: Optional[SortOrder] = Field(None, alias='SortOrder')


class CurrentMetricSortCriteriaMaxOne(RootModel[List[CurrentMetricSortCriteria]]):
    root: List[CurrentMetricSortCriteria] = Field(..., max_length=1, min_length=0)


class CurrentMetrics(RootModel[List[CurrentMetric]]):
    root: List[CurrentMetric]


class DateReference(BaseModel):
    Name: Optional[ReferenceKey] = None
    Value: Optional[ReferenceValue] = None


class DefaultVocabulary(BaseModel):
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    LanguageCode: VocabularyLanguageCode
    VocabularyId_1: VocabularyId = Field(..., alias='VocabularyId')
    VocabularyName_1: VocabularyName = Field(..., alias='VocabularyName')


class DefaultVocabularyList(RootModel[List[DefaultVocabulary]]):
    root: List[DefaultVocabulary]


class DeleteVocabularyResponse(BaseModel):
    State: VocabularyState
    VocabularyArn: ARN
    VocabularyId_1: VocabularyId = Field(..., alias='VocabularyId')


class DescribeInstanceAttributeResponse(BaseModel):
    Attribute_1: Optional[Attribute] = Field(None, alias='Attribute')


class Dimensions(BaseModel):
    Channel_1: Optional[Channel] = Field(None, alias='Channel')
    Queue: Optional[QueueReference] = None
    RoutingProfile: Optional[RoutingProfileReference] = None


class DimensionsV2Map(RootModel[Optional[Dict[str, DimensionsV2Value]]]):
    root: Optional[Dict[str, DimensionsV2Value]] = None


class DisassociateQueueQuickConnectsRequest(BaseModel):
    QuickConnectIds: QuickConnectsList


class DisassociateRoutingProfileQueuesRequest(BaseModel):
    QueueReferences: RoutingProfileQueueReferenceList


class Distribution(BaseModel):
    Percentage_1: Percentage = Field(..., alias='Percentage')
    Region: AwsRegion


class DistributionList(RootModel[List[Distribution]]):
    root: List[Distribution]


class EmailReference(BaseModel):
    Name: Optional[ReferenceKey] = None
    Value: Optional[ReferenceValue] = None


class EncryptionConfig(BaseModel):
    EncryptionType_1: EncryptionType = Field(..., alias='EncryptionType')
    KeyId_1: KeyId = Field(..., alias='KeyId')


class EventBridgeActionDefinition(BaseModel):
    Name: EventBridgeActionName


class FilterValueList(RootModel[List[ResourceArnOrId]]):
    root: List[ResourceArnOrId] = Field(..., max_length=100, min_length=1)


class GetCurrentMetricDataRequest(BaseModel):
    CurrentMetrics_1: CurrentMetrics = Field(..., alias='CurrentMetrics')
    Filters_1: Filters = Field(..., alias='Filters')
    Groupings_1: Optional[Groupings] = Field(None, alias='Groupings')
    MaxResults: Optional[MaxResult100] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SortCriteria: Optional[CurrentMetricSortCriteriaMaxOne] = None


class GetFederationTokenResponse(BaseModel):
    Credentials_1: Optional[Credentials] = Field(None, alias='Credentials')
    SignInUrl: Optional[Url] = None
    UserArn: Optional[ARN] = None
    UserId: Optional[AgentResourceId] = None


class HierarchyGroupCondition(BaseModel):
    HierarchyGroupMatchType_1: Optional[HierarchyGroupMatchType] = Field(
        None, alias='HierarchyGroupMatchType'
    )
    Value: Optional[String] = None


class HierarchyLevel(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[HierarchyLevelId] = None
    Name: Optional[HierarchyLevelName] = None


class HierarchyStructure(BaseModel):
    LevelFive: Optional[HierarchyLevel] = None
    LevelFour: Optional[HierarchyLevel] = None
    LevelOne: Optional[HierarchyLevel] = None
    LevelThree: Optional[HierarchyLevel] = None
    LevelTwo: Optional[HierarchyLevel] = None


class HoursOfOperationTimeSlice(BaseModel):
    Hours: Hours24Format
    Minutes: MinutesLimit60


class InstanceStatusReason(BaseModel):
    Message: Optional[String] = None


class InstanceSummary(BaseModel):
    Arn: Optional[ARN] = None
    CreatedTime: Optional[Timestamp] = None
    Id: Optional[InstanceId] = None
    IdentityManagementType: Optional[DirectoryType] = None
    InboundCallsEnabled_1: Optional[InboundCallsEnabled] = Field(
        None, alias='InboundCallsEnabled'
    )
    InstanceAlias: Optional[DirectoryAlias] = None
    InstanceStatus_1: Optional[InstanceStatus] = Field(None, alias='InstanceStatus')
    OutboundCallsEnabled_1: Optional[OutboundCallsEnabled] = Field(
        None, alias='OutboundCallsEnabled'
    )
    ServiceRole: Optional[ARN] = None


class InstanceSummaryList(RootModel[List[InstanceSummary]]):
    root: List[InstanceSummary]


class IntegrationAssociationSummary(BaseModel):
    InstanceId_1: Optional[InstanceId] = Field(None, alias='InstanceId')
    IntegrationArn: Optional[ARN] = None
    IntegrationAssociationArn: Optional[ARN] = None
    IntegrationAssociationId_1: Optional[IntegrationAssociationId] = Field(
        None, alias='IntegrationAssociationId'
    )
    IntegrationType_1: Optional[IntegrationType] = Field(None, alias='IntegrationType')
    SourceApplicationName_1: Optional[SourceApplicationName] = Field(
        None, alias='SourceApplicationName'
    )
    SourceApplicationUrl: Optional[URI] = None
    SourceType_1: Optional[SourceType] = Field(None, alias='SourceType')


class IntegrationAssociationSummaryList(RootModel[List[IntegrationAssociationSummary]]):
    root: List[IntegrationAssociationSummary]


class KinesisVideoStreamConfig(BaseModel):
    EncryptionConfig_1: EncryptionConfig = Field(..., alias='EncryptionConfig')
    Prefix_1: Prefix = Field(..., alias='Prefix')
    RetentionPeriodHours: Hours


class LexBot(BaseModel):
    LexRegion_1: LexRegion = Field(..., alias='LexRegion')
    Name: BotName


class LexBotConfig(BaseModel):
    LexBot_1: Optional[LexBot] = Field(None, alias='LexBot')
    LexV2Bot_1: Optional[LexV2Bot] = Field(None, alias='LexV2Bot')


class LexBotConfigList(RootModel[List[LexBotConfig]]):
    root: List[LexBotConfig]


class LexBotsList(RootModel[List[LexBot]]):
    root: List[LexBot]


class ListAgentStatusResponse(BaseModel):
    AgentStatusSummaryList_1: Optional[AgentStatusSummaryList] = Field(
        None, alias='AgentStatusSummaryList'
    )
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListApprovedOriginsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    Origins: Optional[OriginsList] = None


class ListBotsResponse(BaseModel):
    LexBots: Optional[LexBotConfigList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListContactFlowModulesResponse(BaseModel):
    ContactFlowModulesSummaryList_1: Optional[ContactFlowModulesSummaryList] = Field(
        None, alias='ContactFlowModulesSummaryList'
    )
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListContactFlowsResponse(BaseModel):
    ContactFlowSummaryList_1: Optional[ContactFlowSummaryList] = Field(
        None, alias='ContactFlowSummaryList'
    )
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListDefaultVocabulariesRequest(BaseModel):
    LanguageCode: Optional[VocabularyLanguageCode] = None
    MaxResults: Optional[MaxResult100] = None
    NextToken: Optional[VocabularyNextToken] = None


class ListDefaultVocabulariesResponse(BaseModel):
    DefaultVocabularyList_1: DefaultVocabularyList = Field(
        ..., alias='DefaultVocabularyList'
    )
    NextToken: Optional[VocabularyNextToken] = None


class ListHoursOfOperationsResponse(BaseModel):
    HoursOfOperationSummaryList_1: Optional[HoursOfOperationSummaryList] = Field(
        None, alias='HoursOfOperationSummaryList'
    )
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListInstanceAttributesResponse(BaseModel):
    Attributes: Optional[AttributesList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListInstancesResponse(BaseModel):
    InstanceSummaryList_1: Optional[InstanceSummaryList] = Field(
        None, alias='InstanceSummaryList'
    )
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListIntegrationAssociationsResponse(BaseModel):
    IntegrationAssociationSummaryList_1: Optional[IntegrationAssociationSummaryList] = (
        Field(None, alias='IntegrationAssociationSummaryList')
    )
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListLambdaFunctionsResponse(BaseModel):
    LambdaFunctions: Optional[FunctionArnsList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListLexBotsResponse(BaseModel):
    LexBots: Optional[LexBotsList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListPhoneNumbersSummary(BaseModel):
    PhoneNumber_1: Optional[PhoneNumber] = Field(None, alias='PhoneNumber')
    PhoneNumberArn: Optional[ARN] = None
    PhoneNumberCountryCode_1: Optional[PhoneNumberCountryCode] = Field(
        None, alias='PhoneNumberCountryCode'
    )
    PhoneNumberId_1: Optional[PhoneNumberId] = Field(None, alias='PhoneNumberId')
    PhoneNumberType_1: Optional[PhoneNumberType] = Field(None, alias='PhoneNumberType')
    TargetArn: Optional[ARN] = None


class ListPhoneNumbersSummaryList(RootModel[List[ListPhoneNumbersSummary]]):
    root: List[ListPhoneNumbersSummary]


class ListPhoneNumbersV2Request(BaseModel):
    MaxResults: Optional[MaxResult1000] = None
    NextToken: Optional[LargeNextToken] = None
    PhoneNumberCountryCodes_1: Optional[PhoneNumberCountryCodes] = Field(
        None, alias='PhoneNumberCountryCodes'
    )
    PhoneNumberPrefix_1: Optional[PhoneNumberPrefix] = Field(
        None, alias='PhoneNumberPrefix'
    )
    PhoneNumberTypes_1: Optional[PhoneNumberTypes] = Field(
        None, alias='PhoneNumberTypes'
    )
    TargetArn: Optional[ARN] = None


class ListPhoneNumbersV2Response(BaseModel):
    ListPhoneNumbersSummaryList_1: Optional[ListPhoneNumbersSummaryList] = Field(
        None, alias='ListPhoneNumbersSummaryList'
    )
    NextToken: Optional[LargeNextToken] = None


class ListPromptsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    PromptSummaryList_1: Optional[PromptSummaryList] = Field(
        None, alias='PromptSummaryList'
    )


class ListRoutingProfileQueuesResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    RoutingProfileQueueConfigSummaryList_1: Optional[
        RoutingProfileQueueConfigSummaryList
    ] = Field(None, alias='RoutingProfileQueueConfigSummaryList')


class ListRoutingProfilesResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    RoutingProfileSummaryList_1: Optional[RoutingProfileSummaryList] = Field(
        None, alias='RoutingProfileSummaryList'
    )


class ListSecurityProfilesResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SecurityProfileSummaryList_1: Optional[SecurityProfileSummaryList] = Field(
        None, alias='SecurityProfileSummaryList'
    )


class ListTrafficDistributionGroupsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    TrafficDistributionGroupSummaryList_1: Optional[
        TrafficDistributionGroupSummaryList
    ] = Field(None, alias='TrafficDistributionGroupSummaryList')


class ListUserHierarchyGroupsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    UserHierarchyGroupSummaryList: Optional[HierarchyGroupSummaryList] = None


class ListUsersResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    UserSummaryList_1: Optional[UserSummaryList] = Field(None, alias='UserSummaryList')


class MediaConcurrencies(RootModel[List[MediaConcurrency]]):
    root: List[MediaConcurrency]


class MetricFilterValueList(RootModel[List[String]]):
    root: List[String] = Field(..., max_length=10, min_length=1)


class MonitorContactRequest(BaseModel):
    AllowedMonitorCapabilities_1: Optional[AllowedMonitorCapabilities] = Field(
        None, alias='AllowedMonitorCapabilities'
    )
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    UserId: AgentResourceId


class NotificationRecipientType(BaseModel):
    UserIds: Optional[UserIdList] = None
    UserTags: Optional[UserTagMap] = None


class NumberReference(BaseModel):
    Name: Optional[ReferenceKey] = None
    Value: Optional[ReferenceValue] = None


class ParticipantDetailsToAdd(BaseModel):
    DisplayName_1: Optional[DisplayName] = Field(None, alias='DisplayName')
    ParticipantRole_1: Optional[ParticipantRole] = Field(None, alias='ParticipantRole')


class ParticipantTimerConfiguration(BaseModel):
    ParticipantRole: TimerEligibleParticipantRoles
    TimerType: ParticipantTimerType
    TimerValue: ParticipantTimerValue


class PermissionsList(RootModel[List[SecurityProfilePermission]]):
    root: List[SecurityProfilePermission] = Field(..., max_length=500)


class PhoneNumberStatus(BaseModel):
    Message: Optional[PhoneNumberWorkflowMessage] = None
    Status: Optional[PhoneNumberWorkflowStatus] = None


class PhoneNumberSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[PhoneNumberId] = None
    PhoneNumber_1: Optional[PhoneNumber] = Field(None, alias='PhoneNumber')
    PhoneNumberCountryCode_1: Optional[PhoneNumberCountryCode] = Field(
        None, alias='PhoneNumberCountryCode'
    )
    PhoneNumberType_1: Optional[PhoneNumberType] = Field(None, alias='PhoneNumberType')


class PhoneNumberSummaryList(RootModel[List[PhoneNumberSummary]]):
    root: List[PhoneNumberSummary]


class QueueInfo(BaseModel):
    EnqueueTimestamp: Optional[Timestamp] = None
    Id: Optional[QueueId] = None


class QueueSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[QueueId] = None
    Name: Optional[QueueName] = None
    QueueType_1: Optional[QueueType] = Field(None, alias='QueueType')


class QueueSummaryList(RootModel[List[QueueSummary]]):
    root: List[QueueSummary]


class QuickConnectConfig(BaseModel):
    PhoneConfig: Optional[PhoneNumberQuickConnectConfig] = None
    QueueConfig: Optional[QueueQuickConnectConfig] = None
    QuickConnectType_1: QuickConnectType = Field(..., alias='QuickConnectType')
    UserConfig: Optional[UserQuickConnectConfig] = None


class QuickConnectSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[QuickConnectId] = None
    Name: Optional[QuickConnectName] = None
    QuickConnectType_1: Optional[QuickConnectType] = Field(
        None, alias='QuickConnectType'
    )


class QuickConnectSummaryList(RootModel[List[QuickConnectSummary]]):
    root: List[QuickConnectSummary]


class Reference(BaseModel):
    Type: ReferenceType
    Value: ReferenceValue


class ReferenceSummary(BaseModel):
    Attachment: Optional[AttachmentReference] = None
    Date: Optional[DateReference] = None
    Email: Optional[EmailReference] = None
    Number: Optional[NumberReference] = None
    String: Optional[StringReference] = None
    Url: Optional[UrlReference] = None


class ReferenceSummaryList(RootModel[List[ReferenceSummary]]):
    root: List[ReferenceSummary]


class RoutingProfileQueueConfig(BaseModel):
    Delay_1: Delay = Field(..., alias='Delay')
    Priority_1: Priority = Field(..., alias='Priority')
    QueueReference: RoutingProfileQueueReference


class RoutingProfileQueueConfigList(RootModel[List[RoutingProfileQueueConfig]]):
    root: List[RoutingProfileQueueConfig] = Field(..., max_length=10, min_length=1)


class S3Config(BaseModel):
    BucketName_1: BucketName = Field(..., alias='BucketName')
    BucketPrefix: Prefix
    EncryptionConfig_1: Optional[EncryptionConfig] = Field(
        None, alias='EncryptionConfig'
    )


class SearchAvailablePhoneNumbersResponse(BaseModel):
    AvailableNumbersList_1: Optional[AvailableNumbersList] = Field(
        None, alias='AvailableNumbersList'
    )
    NextToken: Optional[LargeNextToken] = None


class SearchVocabulariesRequest(BaseModel):
    LanguageCode: Optional[VocabularyLanguageCode] = None
    MaxResults: Optional[MaxResult100] = None
    NameStartsWith: Optional[VocabularyName] = None
    NextToken: Optional[VocabularyNextToken] = None
    State: Optional[VocabularyState] = None


class SearchVocabulariesResponse(BaseModel):
    NextToken: Optional[VocabularyNextToken] = None
    VocabularySummaryList_1: Optional[VocabularySummaryList] = Field(
        None, alias='VocabularySummaryList'
    )


class SecurityKey(BaseModel):
    AssociationId_1: Optional[AssociationId] = Field(None, alias='AssociationId')
    CreationTime: Optional[Timestamp] = None
    Key: Optional[PEM] = None


class SecurityKeysList(RootModel[List[SecurityKey]]):
    root: List[SecurityKey]


class SendNotificationActionDefinition(BaseModel):
    Content_1: Content = Field(..., alias='Content')
    ContentType: NotificationContentType
    DeliveryMethod: NotificationDeliveryType
    Recipient: NotificationRecipientType
    Subject_1: Optional[Subject] = Field(None, alias='Subject')


class SingleSelectOptions(RootModel[List[TaskTemplateSingleSelectOption]]):
    root: List[TaskTemplateSingleSelectOption]


class StartChatContactRequest(BaseModel):
    Attributes_1: Optional[Attributes] = Field(None, alias='Attributes')
    ChatDurationInMinutes_1: Optional[ChatDurationInMinutes] = Field(
        None, alias='ChatDurationInMinutes'
    )
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    ContactFlowId_1: ContactFlowId = Field(..., alias='ContactFlowId')
    InitialMessage: Optional[ChatMessage] = None
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    ParticipantDetails_1: ParticipantDetails = Field(..., alias='ParticipantDetails')
    PersistentChat_1: Optional[PersistentChat] = Field(None, alias='PersistentChat')
    RelatedContactId: Optional[ContactId] = None
    SupportedMessagingContentTypes_1: Optional[SupportedMessagingContentTypes] = Field(
        None, alias='SupportedMessagingContentTypes'
    )


class StartContactStreamingRequest(BaseModel):
    ChatStreamingConfiguration_1: ChatStreamingConfiguration = Field(
        ..., alias='ChatStreamingConfiguration'
    )
    ClientToken_1: ClientToken = Field(..., alias='ClientToken')
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')


class StartContactStreamingResponse(BaseModel):
    StreamingId_1: StreamingId = Field(..., alias='StreamingId')


class StartOutboundVoiceContactRequest(BaseModel):
    AnswerMachineDetectionConfig_1: Optional[AnswerMachineDetectionConfig] = Field(
        None, alias='AnswerMachineDetectionConfig'
    )
    Attributes_1: Optional[Attributes] = Field(None, alias='Attributes')
    CampaignId_1: Optional[CampaignId] = Field(None, alias='CampaignId')
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    ContactFlowId_1: ContactFlowId = Field(..., alias='ContactFlowId')
    DestinationPhoneNumber: PhoneNumber
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    QueueId_1: Optional[QueueId] = Field(None, alias='QueueId')
    SourcePhoneNumber: Optional[PhoneNumber] = None
    TrafficType_1: Optional[TrafficType] = Field(None, alias='TrafficType')


class StopContactStreamingRequest(BaseModel):
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    StreamingId_1: StreamingId = Field(..., alias='StreamingId')


class TagAndConditionList(RootModel[List[TagCondition]]):
    root: List[TagCondition]


class TagMap(RootModel[Optional[Dict[str, TagValue]]]):
    root: Optional[Dict[str, TagValue]] = None


class TagOrConditionList(RootModel[List[TagAndConditionList]]):
    root: List[TagAndConditionList]


class TagResourceRequest(BaseModel):
    tags: TagMap


class TagRestrictedResourceList(RootModel[List[TagRestrictedResourceName]]):
    root: List[TagRestrictedResourceName] = Field(..., max_length=10)


class TaskTemplateFieldIdentifier(BaseModel):
    Name: Optional[TaskTemplateFieldName] = None


class TaskTemplateMetadata(BaseModel):
    Arn: Optional[TaskTemplateArn] = None
    CreatedTime: Optional[Timestamp] = None
    Description: Optional[TaskTemplateDescription] = None
    Id: Optional[TaskTemplateId] = None
    LastModifiedTime: Optional[Timestamp] = None
    Name: Optional[TaskTemplateName] = None
    Status: Optional[TaskTemplateStatus] = None


class TelephonyConfig(BaseModel):
    Distributions: DistributionList


class Threshold(BaseModel):
    Comparison_1: Optional[Comparison] = Field(None, alias='Comparison')
    ThresholdValue_1: Optional[ThresholdValue] = Field(None, alias='ThresholdValue')


class ThresholdV2(BaseModel):
    Comparison: Optional[ResourceArnOrId] = None
    ThresholdValue_1: Optional[ThresholdValue] = Field(None, alias='ThresholdValue')


class TrafficDistributionGroup(BaseModel):
    Arn: Optional[TrafficDistributionGroupArn] = None
    Description: Optional[Description250] = None
    Id: Optional[TrafficDistributionGroupId] = None
    InstanceArn_1: Optional[InstanceArn] = Field(None, alias='InstanceArn')
    Name: Optional[Name128] = None
    Status: Optional[TrafficDistributionGroupStatus] = None
    Tags: Optional[TagMap] = None


class UpdateQueueOutboundCallerConfigRequest(BaseModel):
    OutboundCallerConfig_1: OutboundCallerConfig = Field(
        ..., alias='OutboundCallerConfig'
    )


class UpdateQuickConnectConfigRequest(BaseModel):
    QuickConnectConfig_1: QuickConnectConfig = Field(..., alias='QuickConnectConfig')


class UpdateRoutingProfileConcurrencyRequest(BaseModel):
    MediaConcurrencies_1: MediaConcurrencies = Field(..., alias='MediaConcurrencies')


class UpdateRoutingProfileQueuesRequest(BaseModel):
    QueueConfigs: RoutingProfileQueueConfigList


class UpdateSecurityProfileRequest(BaseModel):
    AllowedAccessControlTags_1: Optional[AllowedAccessControlTags] = Field(
        None, alias='AllowedAccessControlTags'
    )
    Description: Optional[SecurityProfileDescription] = None
    Permissions: Optional[PermissionsList] = None
    TagRestrictedResources: Optional[TagRestrictedResourceList] = None


class UpdateTrafficDistributionRequest(BaseModel):
    TelephonyConfig_1: Optional[TelephonyConfig] = Field(None, alias='TelephonyConfig')


class UpdateUserIdentityInfoRequest(BaseModel):
    IdentityInfo: UserIdentityInfo


class UpdateUserPhoneConfigRequest(BaseModel):
    PhoneConfig: UserPhoneConfig


class UseCase(BaseModel):
    UseCaseArn: Optional[ARN] = None
    UseCaseId_1: Optional[UseCaseId] = Field(None, alias='UseCaseId')
    UseCaseType_1: Optional[UseCaseType] = Field(None, alias='UseCaseType')


class UseCaseSummaryList(RootModel[List[UseCase]]):
    root: List[UseCase]


class User(BaseModel):
    Arn: Optional[ARN] = None
    DirectoryUserId_1: Optional[DirectoryUserId] = Field(None, alias='DirectoryUserId')
    HierarchyGroupId_1: Optional[HierarchyGroupId] = Field(
        None, alias='HierarchyGroupId'
    )
    Id: Optional[UserId] = None
    IdentityInfo: Optional[UserIdentityInfo] = None
    PhoneConfig: Optional[UserPhoneConfig] = None
    RoutingProfileId_1: Optional[RoutingProfileId] = Field(
        None, alias='RoutingProfileId'
    )
    SecurityProfileIds_1: Optional[SecurityProfileIds] = Field(
        None, alias='SecurityProfileIds'
    )
    Tags: Optional[TagMap] = None
    Username: Optional[AgentUsername] = None


class UserData(BaseModel):
    ActiveSlotsByChannel: Optional[ChannelToCountMap] = None
    AvailableSlotsByChannel: Optional[ChannelToCountMap] = None
    Contacts: Optional[AgentContactReferenceList] = None
    HierarchyPath: Optional[HierarchyPathReference] = None
    MaxSlotsByChannel: Optional[ChannelToCountMap] = None
    NextStatus: Optional[AgentStatusName] = None
    RoutingProfile: Optional[RoutingProfileReference] = None
    Status: Optional[AgentStatusReference] = None
    User: Optional[UserReference] = None


class UserDataFilters(BaseModel):
    Agents: Optional[AgentsMinOneMaxHundred] = None
    ContactFilter_1: Optional[ContactFilter] = Field(None, alias='ContactFilter')
    Queues_1: Optional[Queues] = Field(None, alias='Queues')
    RoutingProfiles_1: Optional[RoutingProfiles] = Field(None, alias='RoutingProfiles')
    UserHierarchyGroups: Optional[UserDataHierarchyGroups] = None


class UserDataList(RootModel[List[UserData]]):
    root: List[UserData]


class UserSearchSummary(BaseModel):
    Arn: Optional[ARN] = None
    DirectoryUserId_1: Optional[DirectoryUserId] = Field(None, alias='DirectoryUserId')
    HierarchyGroupId_1: Optional[HierarchyGroupId] = Field(
        None, alias='HierarchyGroupId'
    )
    Id: Optional[UserId] = None
    IdentityInfo: Optional[UserIdentityInfoLite] = None
    PhoneConfig: Optional[UserPhoneConfig] = None
    RoutingProfileId_1: Optional[RoutingProfileId] = Field(
        None, alias='RoutingProfileId'
    )
    SecurityProfileIds_1: Optional[SecurityProfileIds] = Field(
        None, alias='SecurityProfileIds'
    )
    Tags: Optional[TagMap] = None
    Username: Optional[AgentUsername] = None


class UserSearchSummaryList(RootModel[List[UserSearchSummary]]):
    root: List[UserSearchSummary]


class Vocabulary(BaseModel):
    Arn: ARN
    Content: Optional[VocabularyContent] = None
    FailureReason: Optional[VocabularyFailureReason] = None
    Id: VocabularyId
    LanguageCode: VocabularyLanguageCode
    LastModifiedTime: VocabularyLastModifiedTime
    Name: VocabularyName
    State: VocabularyState
    Tags: Optional[TagMap] = None


class ContactTaskPutRequest(BaseModel):
    Attributes: Optional[Dict[str, AttributeValue]] = Field(
        None,
        description='<p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.</p> <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.</p>',
    )
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    ContactFlowId: Optional[constr(max_length=500)] = Field(
        None,
        description='<p>The identifier of the flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of the flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p> <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b> </p>',
    )
    Description: Optional[constr(min_length=0, max_length=4096)] = Field(
        None,
        description='A description of the task that is shown to an agent in the Contact Control Panel (CCP).',
    )
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    Name: constr(min_length=0, max_length=512) = Field(
        ...,
        description='The name of a task that is shown to an agent in the Contact Control Panel (CCP).',
    )
    PreviousContactId: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description='The identifier of the previous chat, voice, or task contact. ',
    )
    QuickConnectId: Optional[str] = Field(
        None, description='The identifier for the quick connect.'
    )
    References: Optional[Dict[str, Reference]] = Field(
        None,
        description='A formatted URL that is shown to an agent in the Contact Control Panel (CCP).',
    )
    RelatedContactId: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description='The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/tasks.html#linked-tasks">related</a> to this contact.',
    )
    ScheduledTime: Optional[datetime] = Field(
        None,
        description='The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future. ',
    )
    TaskTemplateId: Optional[constr(min_length=1, max_length=500)] = Field(
        None, description='A unique identifier for the task template.'
    )


class ContactsInstanceIdContactIdPostRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=4096)] = Field(
        None, description='The description of the contact.'
    )
    Name: Optional[constr(min_length=0, max_length=512)] = Field(
        None, description='The name of the contact.'
    )
    References: Optional[Dict[str, Reference]] = Field(
        None,
        description='Well-formed data on contact, shown to agents on Contact Control Panel (CCP).',
    )


class StorageConfig(BaseModel):
    AssociationId_1: Optional[AssociationId] = Field(None, alias='AssociationId')
    KinesisFirehoseConfig_1: Optional[KinesisFirehoseConfig] = Field(
        None, alias='KinesisFirehoseConfig'
    )
    KinesisStreamConfig_1: Optional[KinesisStreamConfig] = Field(
        None, alias='KinesisStreamConfig'
    )
    KinesisVideoStreamConfig_1: Optional[KinesisVideoStreamConfig] = Field(
        None, alias='KinesisVideoStreamConfig'
    )
    S3Config_1: Optional[S3Config] = Field(None, alias='S3Config')
    StorageType_1: Optional[StorageType] = Field(None, alias='StorageType')


class InstanceInstanceIdStorageConfigPutRequest(BaseModel):
    ResourceType_1: ResourceType = Field(
        ..., alias='ResourceType', description='A valid resource type.'
    )
    StorageConfig_1: StorageConfig = Field(
        ...,
        alias='StorageConfig',
        description='The storage configuration for the instance.',
    )


class InstanceInstanceIdStorageConfigAssociationIdResourceTypePostRequest(BaseModel):
    StorageConfig_1: StorageConfig = Field(
        ...,
        alias='StorageConfig',
        description='The storage configuration for the instance.',
    )


class MetricsCurrentInstanceIdPostRequest(BaseModel):
    CurrentMetrics: List[CurrentMetric] = Field(
        ...,
        description='<p>The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p> <dl> <dt>AGENTS_AFTER_CONTACT_WORK</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time">ACW</a> </p> </dd> <dt>AGENTS_AVAILABLE</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time">Available</a> </p> </dd> <dt>AGENTS_ERROR</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time">Error</a> </p> </dd> <dt>AGENTS_NON_PRODUCTIVE</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time">NPT (Non-Productive Time)</a> </p> </dd> <dt>AGENTS_ON_CALL</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p> </dd> <dt>AGENTS_ON_CONTACT</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On contact</a> </p> </dd> <dt>AGENTS_ONLINE</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time">Online</a> </p> </dd> <dt>AGENTS_STAFFED</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time">Staffed</a> </p> </dd> <dt>CONTACTS_IN_QUEUE</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time">In queue</a> </p> </dd> <dt>CONTACTS_SCHEDULED</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time">Scheduled</a> </p> </dd> <dt>OLDEST_CONTACT_AGE</dt> <dd> <p>Unit: SECONDS</p> <p>When you use groupings, Unit says SECONDS and the Value is returned in SECONDS. </p> <p>When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this:</p> <p> <code>{ "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 </code>}</p> <p>The actual OLDEST_CONTACT_AGE is 24 seconds.</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time">Oldest</a> </p> </dd> <dt>SLOTS_ACTIVE</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time">Active</a> </p> </dd> <dt>SLOTS_AVAILABLE</dt> <dd> <p>Unit: COUNT</p> <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time">Availability</a> </p> </dd> </dl>',
    )
    Filters_1: Filters = Field(
        ...,
        alias='Filters',
        description='Contains the filter to apply when retrieving metrics.',
    )
    Groupings: Optional[List[Grouping]] = Field(
        None,
        description='<p>The grouping applied to the metrics returned. For example, when grouped by <code>QUEUE</code>, the metrics returned apply to each queue rather than aggregated for all queues. </p> <ul> <li> <p>If you group by <code>CHANNEL</code>, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.</p> </li> <li> <p>If you group by <code>ROUTING_PROFILE</code>, you must include either a queue or routing profile filter. In addition, a routing profile filter is required for metrics <code>CONTACTS_SCHEDULED</code>, <code>CONTACTS_IN_QUEUE</code>, and <code> OLDEST_CONTACT_AGE</code>.</p> </li> <li> <p>If no <code>Grouping</code> is included in the request, a summary of metrics is returned.</p> </li> </ul>',
        max_length=2,
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[str] = Field(
        None,
        description='<p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p> <p>The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.</p>',
    )
    SortCriteria: Optional[List[CurrentMetricSortCriteria]] = Field(
        None,
        description='<p>The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on <code>AGENTS_ONLINE</code>, <code>DESCENDING</code>. The metric collection is sorted based on the input metrics.</p> <p>Note the following:</p> <ul> <li> <p>Sorting on <code>SLOTS_ACTIVE</code> and <code>SLOTS_AVAILABLE</code> is not supported.</p> </li> </ul>',
        max_length=1,
        min_length=0,
    )


class Filters3(BaseModel):
    Agents: Optional[AgentsMinOneMaxHundred] = None
    ContactFilter_1: Optional[ContactFilter] = Field(None, alias='ContactFilter')
    Queues_1: Optional[Queues] = Field(None, alias='Queues')
    RoutingProfiles_1: Optional[RoutingProfiles] = Field(None, alias='RoutingProfiles')
    UserHierarchyGroups: Optional[UserDataHierarchyGroups] = None


class MetricsUserdataInstanceIdPostRequest(BaseModel):
    Filters: Filters3 = Field(..., description='A filter for the user data.')
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[str] = Field(
        None,
        description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
    )


class RoutingProfilesInstanceIdPutRequest(BaseModel):
    DefaultOutboundQueueId: str = Field(
        ..., description='The default outbound queue for the routing profile.'
    )
    Description: constr(min_length=1, max_length=250) = Field(
        ...,
        description='Description of the routing profile. Must not be more than 250 characters.',
    )
    MediaConcurrencies: List[MediaConcurrency] = Field(
        ...,
        description='The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.',
    )
    Name: constr(min_length=1, max_length=127) = Field(
        ...,
        description='The name of the routing profile. Must not be more than 127 characters.',
    )
    QueueConfigs: Optional[List[RoutingProfileQueueConfig]] = Field(
        None,
        description='<p>The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls.</p> <p>The limit of 10 array members applies to the maximum number of <code>RoutingProfileQueueConfig</code> objects that can be passed during a CreateRoutingProfile API request. It is different from the quota of 50 queues per routing profile per instance that is listed in <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect service quotas</a>. </p>',
        max_length=10,
        min_length=1,
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )


class RoutingProfilesInstanceIdRoutingProfileIdAssociateQueuesPostRequest(BaseModel):
    QueueConfigs: List[RoutingProfileQueueConfig] = Field(
        ...,
        description='The queues to associate with this routing profile.',
        max_length=10,
        min_length=1,
    )


class RoutingProfilesInstanceIdRoutingProfileIdQueuesPostRequest(BaseModel):
    QueueConfigs: List[RoutingProfileQueueConfig] = Field(
        ...,
        description='The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.',
        max_length=10,
        min_length=1,
    )


class TelephonyConfig1(BaseModel):
    Distributions: Optional[DistributionList] = None


class TrafficDistributionIdPutRequest(BaseModel):
    TelephonyConfig: Optional[TelephonyConfig1] = Field(
        None,
        description='The distribution of traffic between the instance and its replicas.',
    )


class ActionSummaries(RootModel[List[ActionSummary]]):
    root: List[ActionSummary]


class AgentStatus(BaseModel):
    AgentStatusARN: Optional[ARN] = None
    AgentStatusId_1: Optional[AgentStatusId] = Field(None, alias='AgentStatusId')
    Description: Optional[AgentStatusDescription] = None
    DisplayOrder: Optional[AgentStatusOrderNumber] = None
    Name: Optional[AgentStatusName] = None
    State: Optional[AgentStatusState] = None
    Tags: Optional[TagMap] = None
    Type: Optional[AgentStatusType] = None


class AssociateBotRequest(BaseModel):
    LexBot_1: Optional[LexBot] = Field(None, alias='LexBot')
    LexV2Bot_1: Optional[LexV2Bot] = Field(None, alias='LexV2Bot')


class AssociateLexBotRequest(BaseModel):
    LexBot_1: LexBot = Field(..., alias='LexBot')


class AssociateRoutingProfileQueuesRequest(BaseModel):
    QueueConfigs: RoutingProfileQueueConfigList


class ClaimPhoneNumberRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    PhoneNumber_1: PhoneNumber = Field(..., alias='PhoneNumber')
    PhoneNumberDescription_1: Optional[PhoneNumberDescription] = Field(
        None, alias='PhoneNumberDescription'
    )
    Tags: Optional[TagMap] = None
    TargetArn: ARN


class ClaimedPhoneNumberSummary(BaseModel):
    PhoneNumber_1: Optional[PhoneNumber] = Field(None, alias='PhoneNumber')
    PhoneNumberArn: Optional[ARN] = None
    PhoneNumberCountryCode_1: Optional[PhoneNumberCountryCode] = Field(
        None, alias='PhoneNumberCountryCode'
    )
    PhoneNumberDescription_1: Optional[PhoneNumberDescription] = Field(
        None, alias='PhoneNumberDescription'
    )
    PhoneNumberId_1: Optional[PhoneNumberId] = Field(None, alias='PhoneNumberId')
    PhoneNumberStatus_1: Optional[PhoneNumberStatus] = Field(
        None, alias='PhoneNumberStatus'
    )
    PhoneNumberType_1: Optional[PhoneNumberType] = Field(None, alias='PhoneNumberType')
    Tags: Optional[TagMap] = None
    TargetArn: Optional[ARN] = None


class Contact(BaseModel):
    AgentInfo_1: Optional[AgentInfo] = Field(None, alias='AgentInfo')
    Arn: Optional[ARN] = None
    Channel_1: Optional[Channel] = Field(None, alias='Channel')
    Description_1: Optional[Description] = Field(None, alias='Description')
    DisconnectTimestamp: Optional[Timestamp] = None
    Id: Optional[ContactId] = None
    InitialContactId: Optional[ContactId] = None
    InitiationMethod: Optional[ContactInitiationMethod] = None
    InitiationTimestamp: Optional[Timestamp] = None
    LastUpdateTimestamp: Optional[Timestamp] = None
    Name_1: Optional[Name] = Field(None, alias='Name')
    PreviousContactId: Optional[ContactId] = None
    QueueInfo_1: Optional[QueueInfo] = Field(None, alias='QueueInfo')
    RelatedContactId: Optional[ContactId] = None
    ScheduledTimestamp: Optional[Timestamp] = None
    WisdomInfo_1: Optional[WisdomInfo] = Field(None, alias='WisdomInfo')


class ContactFlow(BaseModel):
    Arn: Optional[ARN] = None
    Content: Optional[ContactFlowContent] = None
    Description: Optional[ContactFlowDescription] = None
    Id: Optional[ContactFlowId] = None
    Name: Optional[ContactFlowName] = None
    State: Optional[ContactFlowState] = None
    Tags: Optional[TagMap] = None
    Type: Optional[ContactFlowType] = None


class ContactFlowModule(BaseModel):
    Arn: Optional[ARN] = None
    Content: Optional[ContactFlowModuleContent] = None
    Description: Optional[ContactFlowModuleDescription] = None
    Id: Optional[ContactFlowModuleId] = None
    Name: Optional[ContactFlowModuleName] = None
    State: Optional[ContactFlowModuleState] = None
    Status: Optional[ContactFlowModuleStatus] = None
    Tags: Optional[TagMap] = None


class ContactReferences(RootModel[Optional[Dict[str, Reference]]]):
    root: Optional[Dict[str, Reference]] = None


class ControlPlaneTagFilter(BaseModel):
    AndConditions: Optional[TagAndConditionList] = None
    OrConditions: Optional[TagOrConditionList] = None
    TagCondition_1: Optional[TagCondition] = Field(None, alias='TagCondition')


class CreateAgentStatusRequest(BaseModel):
    Description: Optional[AgentStatusDescription] = None
    DisplayOrder: Optional[AgentStatusOrderNumber] = None
    Name: AgentStatusName
    State: AgentStatusState
    Tags: Optional[TagMap] = None


class CreateContactFlowModuleRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    Content: ContactFlowModuleContent
    Description: Optional[ContactFlowModuleDescription] = None
    Name: ContactFlowModuleName
    Tags: Optional[TagMap] = None


class CreateContactFlowRequest(BaseModel):
    Content: ContactFlowContent
    Description: Optional[ContactFlowDescription] = None
    Name: ContactFlowName
    Tags: Optional[TagMap] = None
    Type: ContactFlowType


class CreateIntegrationAssociationRequest(BaseModel):
    IntegrationArn: ARN
    IntegrationType_1: IntegrationType = Field(..., alias='IntegrationType')
    SourceApplicationName_1: Optional[SourceApplicationName] = Field(
        None, alias='SourceApplicationName'
    )
    SourceApplicationUrl: Optional[URI] = None
    SourceType_1: Optional[SourceType] = Field(None, alias='SourceType')
    Tags: Optional[TagMap] = None


class CreateParticipantRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    ParticipantDetails: ParticipantDetailsToAdd


class CreateQueueRequest(BaseModel):
    Description: Optional[QueueDescription] = None
    HoursOfOperationId_1: HoursOfOperationId = Field(..., alias='HoursOfOperationId')
    MaxContacts: Optional[QueueMaxContacts] = None
    Name: CommonNameLength127
    OutboundCallerConfig_1: Optional[OutboundCallerConfig] = Field(
        None, alias='OutboundCallerConfig'
    )
    QuickConnectIds: Optional[QuickConnectsList] = None
    Tags: Optional[TagMap] = None


class CreateQuickConnectRequest(BaseModel):
    Description: Optional[QuickConnectDescription] = None
    Name: QuickConnectName
    QuickConnectConfig_1: QuickConnectConfig = Field(..., alias='QuickConnectConfig')
    Tags: Optional[TagMap] = None


class CreateRoutingProfileRequest(BaseModel):
    DefaultOutboundQueueId: QueueId
    Description: RoutingProfileDescription
    MediaConcurrencies_1: MediaConcurrencies = Field(..., alias='MediaConcurrencies')
    Name: RoutingProfileName
    QueueConfigs: Optional[RoutingProfileQueueConfigList] = None
    Tags: Optional[TagMap] = None


class CreateSecurityProfileRequest(BaseModel):
    AllowedAccessControlTags_1: Optional[AllowedAccessControlTags] = Field(
        None, alias='AllowedAccessControlTags'
    )
    Description: Optional[SecurityProfileDescription] = None
    Permissions: Optional[PermissionsList] = None
    SecurityProfileName: CreateSecurityProfileName
    TagRestrictedResources: Optional[TagRestrictedResourceList] = None
    Tags: Optional[TagMap] = None


class CreateTrafficDistributionGroupRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    Description: Optional[Description250] = None
    InstanceId: InstanceIdOrArn
    Name: Name128
    Tags: Optional[TagMap] = None


class CreateUseCaseRequest(BaseModel):
    Tags: Optional[TagMap] = None
    UseCaseType_1: UseCaseType = Field(..., alias='UseCaseType')


class CreateUserHierarchyGroupRequest(BaseModel):
    Name: HierarchyGroupName
    ParentGroupId: Optional[HierarchyGroupId] = None
    Tags: Optional[TagMap] = None


class CreateUserRequest(BaseModel):
    DirectoryUserId_1: Optional[DirectoryUserId] = Field(None, alias='DirectoryUserId')
    HierarchyGroupId_1: Optional[HierarchyGroupId] = Field(
        None, alias='HierarchyGroupId'
    )
    IdentityInfo: Optional[UserIdentityInfo] = None
    Password_1: Optional[Password] = Field(None, alias='Password')
    PhoneConfig: UserPhoneConfig
    RoutingProfileId_1: RoutingProfileId = Field(..., alias='RoutingProfileId')
    SecurityProfileIds_1: SecurityProfileIds = Field(..., alias='SecurityProfileIds')
    Tags: Optional[TagMap] = None
    Username: AgentUsername


class CreateVocabularyRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    Content: VocabularyContent
    LanguageCode: VocabularyLanguageCode
    Tags: Optional[TagMap] = None
    VocabularyName_1: VocabularyName = Field(..., alias='VocabularyName')


class CurrentMetricResult(BaseModel):
    Collections: Optional[CurrentMetricDataCollections] = None
    Dimensions_1: Optional[Dimensions] = Field(None, alias='Dimensions')


class CurrentMetricResults(RootModel[List[CurrentMetricResult]]):
    root: List[CurrentMetricResult]


class DescribeAgentStatusResponse(BaseModel):
    AgentStatus_1: Optional[AgentStatus] = Field(None, alias='AgentStatus')


class DescribeContactFlowModuleResponse(BaseModel):
    ContactFlowModule_1: Optional[ContactFlowModule] = Field(
        None, alias='ContactFlowModule'
    )


class DescribeContactFlowResponse(BaseModel):
    ContactFlow_1: Optional[ContactFlow] = Field(None, alias='ContactFlow')


class DescribeContactResponse(BaseModel):
    Contact_1: Optional[Contact] = Field(None, alias='Contact')


class DescribePhoneNumberResponse(BaseModel):
    ClaimedPhoneNumberSummary_1: Optional[ClaimedPhoneNumberSummary] = Field(
        None, alias='ClaimedPhoneNumberSummary'
    )


class DescribeTrafficDistributionGroupResponse(BaseModel):
    TrafficDistributionGroup_1: Optional[TrafficDistributionGroup] = Field(
        None, alias='TrafficDistributionGroup'
    )


class DescribeUserHierarchyStructureResponse(BaseModel):
    HierarchyStructure_1: Optional[HierarchyStructure] = Field(
        None, alias='HierarchyStructure'
    )


class DescribeUserResponse(BaseModel):
    User_1: Optional[User] = Field(None, alias='User')


class DescribeVocabularyResponse(BaseModel):
    Vocabulary_1: Vocabulary = Field(..., alias='Vocabulary')


class DisassociateBotRequest(BaseModel):
    LexBot_1: Optional[LexBot] = Field(None, alias='LexBot')
    LexV2Bot_1: Optional[LexV2Bot] = Field(None, alias='LexV2Bot')


class FilterV2(BaseModel):
    FilterKey: Optional[ResourceArnOrId] = None
    FilterValues: Optional[FilterValueList] = None


class FiltersV2List(RootModel[List[FilterV2]]):
    root: List[FilterV2] = Field(..., max_length=5, min_length=1)


class GetCurrentMetricDataResponse(BaseModel):
    ApproximateTotalCount_1: Optional[ApproximateTotalCount] = Field(
        None, alias='ApproximateTotalCount'
    )
    DataSnapshotTime: Optional[Timestamp] = None
    MetricResults: Optional[CurrentMetricResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class GetCurrentUserDataRequest(BaseModel):
    Filters: UserDataFilters
    MaxResults: Optional[MaxResult100] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class GetCurrentUserDataResponse(BaseModel):
    ApproximateTotalCount_1: Optional[ApproximateTotalCount] = Field(
        None, alias='ApproximateTotalCount'
    )
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    UserDataList_1: Optional[UserDataList] = Field(None, alias='UserDataList')


class GetTrafficDistributionResponse(BaseModel):
    Arn: Optional[TrafficDistributionGroupArn] = None
    Id: Optional[TrafficDistributionGroupId] = None
    TelephonyConfig_1: Optional[TelephonyConfig] = Field(None, alias='TelephonyConfig')


class HierarchyGroup(BaseModel):
    Arn: Optional[ARN] = None
    HierarchyPath_1: Optional[HierarchyPath] = Field(None, alias='HierarchyPath')
    Id: Optional[HierarchyGroupId] = None
    LevelId: Optional[HierarchyLevelId] = None
    Name: Optional[HierarchyGroupName] = None
    Tags: Optional[TagMap] = None


class HistoricalMetric(BaseModel):
    Name: Optional[HistoricalMetricName] = None
    Statistic_1: Optional[Statistic] = Field(None, alias='Statistic')
    Threshold_1: Optional[Threshold] = Field(None, alias='Threshold')
    Unit_1: Optional[Unit] = Field(None, alias='Unit')


class HistoricalMetricData(BaseModel):
    Metric: Optional[HistoricalMetric] = None
    Value_1: Optional[Value] = Field(None, alias='Value')


class HistoricalMetricDataCollections(RootModel[List[HistoricalMetricData]]):
    root: List[HistoricalMetricData]


class HistoricalMetricResult(BaseModel):
    Collections: Optional[HistoricalMetricDataCollections] = None
    Dimensions_1: Optional[Dimensions] = Field(None, alias='Dimensions')


class HistoricalMetricResults(RootModel[List[HistoricalMetricResult]]):
    root: List[HistoricalMetricResult]


class HistoricalMetrics(RootModel[List[HistoricalMetric]]):
    root: List[HistoricalMetric]


class HoursOfOperationConfig(BaseModel):
    Day: HoursOfOperationDays
    EndTime: HoursOfOperationTimeSlice
    StartTime: HoursOfOperationTimeSlice


class HoursOfOperationConfigList(RootModel[List[HoursOfOperationConfig]]):
    root: List[HoursOfOperationConfig] = Field(..., max_length=100, min_length=0)


class Instance(BaseModel):
    Arn: Optional[ARN] = None
    CreatedTime: Optional[Timestamp] = None
    Id: Optional[InstanceId] = None
    IdentityManagementType: Optional[DirectoryType] = None
    InboundCallsEnabled_1: Optional[InboundCallsEnabled] = Field(
        None, alias='InboundCallsEnabled'
    )
    InstanceAlias: Optional[DirectoryAlias] = None
    InstanceStatus_1: Optional[InstanceStatus] = Field(None, alias='InstanceStatus')
    OutboundCallsEnabled_1: Optional[OutboundCallsEnabled] = Field(
        None, alias='OutboundCallsEnabled'
    )
    ServiceRole: Optional[ARN] = None
    StatusReason: Optional[InstanceStatusReason] = None


class InstanceStorageConfig(BaseModel):
    AssociationId_1: Optional[AssociationId] = Field(None, alias='AssociationId')
    KinesisFirehoseConfig_1: Optional[KinesisFirehoseConfig] = Field(
        None, alias='KinesisFirehoseConfig'
    )
    KinesisStreamConfig_1: Optional[KinesisStreamConfig] = Field(
        None, alias='KinesisStreamConfig'
    )
    KinesisVideoStreamConfig_1: Optional[KinesisVideoStreamConfig] = Field(
        None, alias='KinesisVideoStreamConfig'
    )
    S3Config_1: Optional[S3Config] = Field(None, alias='S3Config')
    StorageType_1: StorageType = Field(..., alias='StorageType')


class InstanceStorageConfigs(RootModel[List[InstanceStorageConfig]]):
    root: List[InstanceStorageConfig]


class InvisibleFieldInfo(BaseModel):
    Id: Optional[TaskTemplateFieldIdentifier] = None


class InvisibleTaskTemplateFields(RootModel[List[InvisibleFieldInfo]]):
    root: List[InvisibleFieldInfo]


class ListContactReferencesResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ReferenceSummaryList_1: Optional[ReferenceSummaryList] = Field(
        None, alias='ReferenceSummaryList'
    )


class ListInstanceStorageConfigsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    StorageConfigs: Optional[InstanceStorageConfigs] = None


class ListPhoneNumbersResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    PhoneNumberSummaryList_1: Optional[PhoneNumberSummaryList] = Field(
        None, alias='PhoneNumberSummaryList'
    )


class ListQueueQuickConnectsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    QuickConnectSummaryList_1: Optional[QuickConnectSummaryList] = Field(
        None, alias='QuickConnectSummaryList'
    )


class ListQueuesResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    QueueSummaryList_1: Optional[QueueSummaryList] = Field(
        None, alias='QueueSummaryList'
    )


class ListQuickConnectsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    QuickConnectSummaryList_1: Optional[QuickConnectSummaryList] = Field(
        None, alias='QuickConnectSummaryList'
    )


class ListSecurityKeysResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SecurityKeys: Optional[SecurityKeysList] = None


class ListSecurityProfilePermissionsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    Permissions: Optional[PermissionsList] = None


class ListTagsForResourceResponse(BaseModel):
    tags: Optional[TagMap] = None


class ListUseCasesResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    UseCaseSummaryList_1: Optional[UseCaseSummaryList] = Field(
        None, alias='UseCaseSummaryList'
    )


class MetricFilterV2(BaseModel):
    MetricFilterKey: Optional[String] = None
    MetricFilterValues: Optional[MetricFilterValueList] = None


class MetricFiltersV2List(RootModel[List[MetricFilterV2]]):
    root: List[MetricFilterV2] = Field(..., max_length=2)


class ParticipantTimerConfigList(RootModel[List[ParticipantTimerConfiguration]]):
    root: List[ParticipantTimerConfiguration] = Field(..., max_length=6, min_length=1)


class Queue(BaseModel):
    Description: Optional[QueueDescription] = None
    HoursOfOperationId_1: Optional[HoursOfOperationId] = Field(
        None, alias='HoursOfOperationId'
    )
    MaxContacts: Optional[QueueMaxContacts] = None
    Name: Optional[CommonNameLength127] = None
    OutboundCallerConfig_1: Optional[OutboundCallerConfig] = Field(
        None, alias='OutboundCallerConfig'
    )
    QueueArn: Optional[ARN] = None
    QueueId_1: Optional[QueueId] = Field(None, alias='QueueId')
    Status: Optional[QueueStatus] = None
    Tags: Optional[TagMap] = None


class QueueSearchFilter(BaseModel):
    TagFilter: Optional[ControlPlaneTagFilter] = None


class QueueSearchSummaryList(RootModel[List[Queue]]):
    root: List[Queue]


class QuickConnect(BaseModel):
    Description: Optional[QuickConnectDescription] = None
    Name: Optional[QuickConnectName] = None
    QuickConnectARN: Optional[ARN] = None
    QuickConnectConfig_1: Optional[QuickConnectConfig] = Field(
        None, alias='QuickConnectConfig'
    )
    QuickConnectId_1: Optional[QuickConnectId] = Field(None, alias='QuickConnectId')
    Tags: Optional[TagMap] = None


class ReadOnlyFieldInfo(BaseModel):
    Id: Optional[TaskTemplateFieldIdentifier] = None


class ReadOnlyTaskTemplateFields(RootModel[List[ReadOnlyFieldInfo]]):
    root: List[ReadOnlyFieldInfo]


class RequiredFieldInfo(BaseModel):
    Id: Optional[TaskTemplateFieldIdentifier] = None


class RequiredTaskTemplateFields(RootModel[List[RequiredFieldInfo]]):
    root: List[RequiredFieldInfo]


class RoutingProfile(BaseModel):
    DefaultOutboundQueueId: Optional[QueueId] = None
    Description: Optional[RoutingProfileDescription] = None
    InstanceId_1: Optional[InstanceId] = Field(None, alias='InstanceId')
    MediaConcurrencies_1: Optional[MediaConcurrencies] = Field(
        None, alias='MediaConcurrencies'
    )
    Name: Optional[RoutingProfileName] = None
    NumberOfAssociatedQueues: Optional[Long] = None
    NumberOfAssociatedUsers: Optional[Long] = None
    RoutingProfileArn: Optional[ARN] = None
    RoutingProfileId_1: Optional[RoutingProfileId] = Field(
        None, alias='RoutingProfileId'
    )
    Tags: Optional[TagMap] = None


class RoutingProfileList(RootModel[List[RoutingProfile]]):
    root: List[RoutingProfile]


class RoutingProfileSearchFilter(BaseModel):
    TagFilter: Optional[ControlPlaneTagFilter] = None


class RuleSummary(BaseModel):
    ActionSummaries_1: ActionSummaries = Field(..., alias='ActionSummaries')
    CreatedTime: Timestamp
    EventSourceName_1: EventSourceName = Field(..., alias='EventSourceName')
    LastUpdatedTime: Timestamp
    Name: RuleName
    PublishStatus: RulePublishStatus
    RuleArn: ARN
    RuleId_1: RuleId = Field(..., alias='RuleId')


class RuleSummaryList(RootModel[List[RuleSummary]]):
    root: List[RuleSummary]


class SearchQueuesResponse(BaseModel):
    ApproximateTotalCount_1: Optional[ApproximateTotalCount] = Field(
        None, alias='ApproximateTotalCount'
    )
    NextToken: Optional[NextToken2500] = None
    Queues: Optional[QueueSearchSummaryList] = None


class SearchRoutingProfilesResponse(BaseModel):
    ApproximateTotalCount_1: Optional[ApproximateTotalCount] = Field(
        None, alias='ApproximateTotalCount'
    )
    NextToken: Optional[NextToken2500] = None
    RoutingProfiles: Optional[RoutingProfileList] = None


class SearchUsersResponse(BaseModel):
    ApproximateTotalCount_1: Optional[ApproximateTotalCount] = Field(
        None, alias='ApproximateTotalCount'
    )
    NextToken: Optional[NextToken2500] = None
    Users: Optional[UserSearchSummaryList] = None


class SecurityProfile(BaseModel):
    AllowedAccessControlTags_1: Optional[AllowedAccessControlTags] = Field(
        None, alias='AllowedAccessControlTags'
    )
    Arn: Optional[ARN] = None
    Description: Optional[SecurityProfileDescription] = None
    Id: Optional[SecurityProfileId] = None
    OrganizationResourceId: Optional[InstanceId] = None
    SecurityProfileName_1: Optional[SecurityProfileName] = Field(
        None, alias='SecurityProfileName'
    )
    TagRestrictedResources: Optional[TagRestrictedResourceList] = None
    Tags: Optional[TagMap] = None


class SecurityProfileSearchSummary(BaseModel):
    Arn: Optional[ARN] = None
    Description: Optional[SecurityProfileDescription] = None
    Id: Optional[SecurityProfileId] = None
    OrganizationResourceId: Optional[InstanceId] = None
    SecurityProfileName_1: Optional[SecurityProfileName] = Field(
        None, alias='SecurityProfileName'
    )
    Tags: Optional[TagMap] = None


class SecurityProfilesSearchFilter(BaseModel):
    TagFilter: Optional[ControlPlaneTagFilter] = None


class SecurityProfilesSearchSummaryList(RootModel[List[SecurityProfileSearchSummary]]):
    root: List[SecurityProfileSearchSummary]


class StartContactRecordingRequest(BaseModel):
    ContactId_1: ContactId = Field(..., alias='ContactId')
    InitialContactId: ContactId
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    VoiceRecordingConfiguration_1: VoiceRecordingConfiguration = Field(
        ..., alias='VoiceRecordingConfiguration'
    )


class StartTaskContactRequest(BaseModel):
    Attributes_1: Optional[Attributes] = Field(None, alias='Attributes')
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    ContactFlowId_1: Optional[ContactFlowId] = Field(None, alias='ContactFlowId')
    Description_1: Optional[Description] = Field(None, alias='Description')
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    Name_1: Name = Field(..., alias='Name')
    PreviousContactId: Optional[ContactId] = None
    QuickConnectId_1: Optional[QuickConnectId] = Field(None, alias='QuickConnectId')
    References: Optional[ContactReferences] = None
    RelatedContactId: Optional[ContactId] = None
    ScheduledTime: Optional[Timestamp] = None
    TaskTemplateId_1: Optional[TaskTemplateId] = Field(None, alias='TaskTemplateId')


class TaskActionDefinition(BaseModel):
    ContactFlowId_1: ContactFlowId = Field(..., alias='ContactFlowId')
    Description: Optional[TaskDescriptionExpression] = None
    Name: TaskNameExpression
    References: Optional[ContactReferences] = None


class TaskTemplateConstraints(BaseModel):
    InvisibleFields: Optional[InvisibleTaskTemplateFields] = None
    ReadOnlyFields: Optional[ReadOnlyTaskTemplateFields] = None
    RequiredFields: Optional[RequiredTaskTemplateFields] = None


class TaskTemplateDefaultFieldValue(BaseModel):
    DefaultValue: Optional[TaskTemplateFieldValue] = None
    Id: Optional[TaskTemplateFieldIdentifier] = None


class TaskTemplateDefaultFieldValueList(RootModel[List[TaskTemplateDefaultFieldValue]]):
    root: List[TaskTemplateDefaultFieldValue]


class TaskTemplateDefaults(BaseModel):
    DefaultFieldValues: Optional[TaskTemplateDefaultFieldValueList] = None


class TaskTemplateField(BaseModel):
    Description: Optional[TaskTemplateFieldDescription] = None
    Id: TaskTemplateFieldIdentifier
    SingleSelectOptions_1: Optional[SingleSelectOptions] = Field(
        None, alias='SingleSelectOptions'
    )
    Type: Optional[TaskTemplateFieldType] = None


class TaskTemplateFields(RootModel[List[TaskTemplateField]]):
    root: List[TaskTemplateField]


class TaskTemplateList(RootModel[List[TaskTemplateMetadata]]):
    root: List[TaskTemplateMetadata]


class ThresholdCollections(RootModel[List[ThresholdV2]]):
    root: List[ThresholdV2] = Field(..., max_length=1)


class UpdateContactRequest(BaseModel):
    Description_1: Optional[Description] = Field(None, alias='Description')
    Name_1: Optional[Name] = Field(None, alias='Name')
    References: Optional[ContactReferences] = None


class UpdateHoursOfOperationRequest(BaseModel):
    Config: Optional[HoursOfOperationConfigList] = None
    Description: Optional[UpdateHoursOfOperationDescription] = None
    Name: Optional[CommonNameLength127] = None
    TimeZone_1: Optional[TimeZone] = Field(None, alias='TimeZone')


class UpdateInstanceStorageConfigRequest(BaseModel):
    StorageConfig: InstanceStorageConfig


class UpdateTaskTemplateRequest(BaseModel):
    Constraints: Optional[TaskTemplateConstraints] = None
    ContactFlowId_1: Optional[ContactFlowId] = Field(None, alias='ContactFlowId')
    Defaults: Optional[TaskTemplateDefaults] = None
    Description: Optional[TaskTemplateDescription] = None
    Fields: Optional[TaskTemplateFields] = None
    Name: Optional[TaskTemplateName] = None
    Status: Optional[TaskTemplateStatus] = None


class UpdateTaskTemplateResponse(BaseModel):
    Arn: Optional[TaskTemplateArn] = None
    Constraints: Optional[TaskTemplateConstraints] = None
    ContactFlowId_1: Optional[ContactFlowId] = Field(None, alias='ContactFlowId')
    CreatedTime: Optional[Timestamp] = None
    Defaults: Optional[TaskTemplateDefaults] = None
    Description: Optional[TaskTemplateDescription] = None
    Fields: Optional[TaskTemplateFields] = None
    Id: Optional[TaskTemplateId] = None
    InstanceId_1: Optional[InstanceId] = Field(None, alias='InstanceId')
    LastModifiedTime: Optional[Timestamp] = None
    Name: Optional[TaskTemplateName] = None
    Status: Optional[TaskTemplateStatus] = None


class UserSearchFilter(BaseModel):
    TagFilter: Optional[ControlPlaneTagFilter] = None


class HoursOfOperationsInstanceIdPutRequest(BaseModel):
    Config: List[HoursOfOperationConfig] = Field(
        ...,
        description='Configuration information for the hours of operation: day, start time, and end time.',
        max_length=100,
        min_length=0,
    )
    Description: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='The description of the hours of operation.'
    )
    Name: constr(min_length=1, max_length=127) = Field(
        ..., description='The name of the hours of operation.'
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.',
    )
    TimeZone: str = Field(..., description='The time zone of the hours of operation.')


class HoursOfOperationsInstanceIdHoursOfOperationIdPostRequest(BaseModel):
    Config: Optional[List[HoursOfOperationConfig]] = Field(
        None,
        description='Configuration information of the hours of operation.',
        max_length=100,
        min_length=0,
    )
    Description: Optional[constr(min_length=0, max_length=250)] = Field(
        None, description='The description of the hours of operation.'
    )
    Name: Optional[constr(min_length=1, max_length=127)] = Field(
        None, description='The name of the hours of operation.'
    )
    TimeZone: Optional[str] = Field(
        None, description='The time zone of the hours of operation.'
    )


class Constraints(BaseModel):
    InvisibleFields: Optional[InvisibleTaskTemplateFields] = None
    ReadOnlyFields: Optional[ReadOnlyTaskTemplateFields] = None
    RequiredFields: Optional[RequiredTaskTemplateFields] = None


class Defaults(BaseModel):
    DefaultFieldValues: Optional[TaskTemplateDefaultFieldValueList] = None


class InstanceInstanceIdTaskTemplatePutRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    Constraints_1: Optional[Constraints] = Field(
        None,
        alias='Constraints',
        description='Describes constraints that apply to the template fields.',
    )
    ContactFlowId: Optional[constr(max_length=500)] = Field(
        None,
        description='The identifier of the flow that runs by default when a task is created by referencing this template.',
    )
    Defaults_1: Optional[Defaults] = Field(
        None,
        alias='Defaults',
        description='Describes default values for fields on a template.',
    )
    Description: Optional[constr(min_length=1, max_length=255)] = Field(
        None, description='The description of the task template.'
    )
    Fields: List[TaskTemplateField] = Field(
        ..., description='Fields that are part of the template.'
    )
    Name: constr(min_length=1, max_length=100) = Field(
        ..., description='The name of the task template.'
    )
    Status_1: Optional[Status] = Field(
        None,
        alias='Status',
        description='Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created. ',
    )


class InstanceInstanceIdTaskTemplateTaskTemplateIdPostRequest(BaseModel):
    Constraints_1: Optional[Constraints] = Field(
        None,
        alias='Constraints',
        description='Describes constraints that apply to the template fields.',
    )
    ContactFlowId: Optional[constr(max_length=500)] = Field(
        None,
        description='The identifier of the flow that runs by default when a task is created by referencing this template.',
    )
    Defaults_1: Optional[Defaults] = Field(
        None,
        alias='Defaults',
        description='Describes default values for fields on a template.',
    )
    Description: Optional[constr(min_length=1, max_length=255)] = Field(
        None, description='The description of the task template.'
    )
    Fields: Optional[List[TaskTemplateField]] = Field(
        None, description='Fields that are part of the template.'
    )
    Name: Optional[constr(min_length=1, max_length=100)] = Field(
        None, description='The name of the task template.'
    )
    Status_1: Optional[Status] = Field(
        None,
        alias='Status',
        description='Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task to refer to it. Tasks can only be created from <code>ACTIVE</code> templates. If a template is marked as <code>INACTIVE</code>, then a task that refers to this template cannot be created.',
    )


class MetricsHistoricalInstanceIdPostRequest(BaseModel):
    EndTime: datetime = Field(
        ...,
        description='<p>The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp.</p> <p>The time range between the start and end time must be less than 24 hours.</p>',
    )
    Filters_1: Filters = Field(
        ...,
        alias='Filters',
        description='Contains the filter to apply when retrieving metrics.',
    )
    Groupings: Optional[List[Grouping]] = Field(
        None,
        description='<p>The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues.</p> <p>If no grouping is specified, a summary of metrics for all queues is returned.</p>',
        max_length=2,
    )
    HistoricalMetrics: List[HistoricalMetric] = Field(
        ...,
        description='<p>The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p> <note> <p>This API does not support a contacts incoming metric (there\'s no CONTACTS_INCOMING metric missing from the documented list). </p> </note> <dl> <dt>ABANDON_TIME</dt> <dd> <p>Unit: SECONDS</p> <p>Statistic: AVG</p> </dd> <dt>AFTER_CONTACT_WORK_TIME</dt> <dd> <p>Unit: SECONDS</p> <p>Statistic: AVG</p> </dd> <dt>API_CONTACTS_HANDLED</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CALLBACK_CONTACTS_HANDLED</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_ABANDONED</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_AGENT_HUNG_UP_FIRST</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_CONSULTED</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_HANDLED</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_HANDLED_INCOMING</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_HANDLED_OUTBOUND</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_HOLD_ABANDONS</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_MISSED</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_QUEUED</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_TRANSFERRED_IN</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_TRANSFERRED_IN_FROM_QUEUE</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_TRANSFERRED_OUT</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>CONTACTS_TRANSFERRED_OUT_FROM_QUEUE</dt> <dd> <p>Unit: COUNT</p> <p>Statistic: SUM</p> </dd> <dt>HANDLE_TIME</dt> <dd> <p>Unit: SECONDS</p> <p>Statistic: AVG</p> </dd> <dt>HOLD_TIME</dt> <dd> <p>Unit: SECONDS</p> <p>Statistic: AVG</p> </dd> <dt>INTERACTION_AND_HOLD_TIME</dt> <dd> <p>Unit: SECONDS</p> <p>Statistic: AVG</p> </dd> <dt>INTERACTION_TIME</dt> <dd> <p>Unit: SECONDS</p> <p>Statistic: AVG</p> </dd> <dt>OCCUPANCY</dt> <dd> <p>Unit: PERCENT</p> <p>Statistic: AVG</p> </dd> <dt>QUEUE_ANSWER_TIME</dt> <dd> <p>Unit: SECONDS</p> <p>Statistic: AVG</p> </dd> <dt>QUEUED_TIME</dt> <dd> <p>Unit: SECONDS</p> <p>Statistic: MAX</p> </dd> <dt>SERVICE_LEVEL</dt> <dd> <p>You can include up to 20 SERVICE_LEVEL metrics in a request.</p> <p>Unit: PERCENT</p> <p>Statistic: AVG</p> <p>Threshold: For <code>ThresholdValue</code>, enter any whole number from 1 to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must enter <code>LT</code> (for "Less than"). </p> </dd> </dl>',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[str] = Field(
        None,
        description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
    )
    StartTime: datetime = Field(
        ...,
        description='<p>The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15.</p> <p>The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.</p>',
    )


class SearchFilter(BaseModel):
    TagFilter: Optional[ControlPlaneTagFilter] = None


class AssociateInstanceStorageConfigRequest(BaseModel):
    ResourceType: InstanceStorageResourceType
    StorageConfig: InstanceStorageConfig


class ChatParticipantRoleConfig(BaseModel):
    ParticipantTimerConfigList_1: ParticipantTimerConfigList = Field(
        ..., alias='ParticipantTimerConfigList'
    )


class CreateHoursOfOperationRequest(BaseModel):
    Config: HoursOfOperationConfigList
    Description: Optional[HoursOfOperationDescription] = None
    Name: CommonNameLength127
    Tags: Optional[TagMap] = None
    TimeZone_1: TimeZone = Field(..., alias='TimeZone')


class CreateTaskTemplateRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    Constraints: Optional[TaskTemplateConstraints] = None
    ContactFlowId_1: Optional[ContactFlowId] = Field(None, alias='ContactFlowId')
    Defaults: Optional[TaskTemplateDefaults] = None
    Description: Optional[TaskTemplateDescription] = None
    Fields: TaskTemplateFields
    Name: TaskTemplateName
    Status: Optional[TaskTemplateStatus] = None


class DescribeInstanceResponse(BaseModel):
    Instance_1: Optional[Instance] = Field(None, alias='Instance')


class DescribeInstanceStorageConfigResponse(BaseModel):
    StorageConfig: Optional[InstanceStorageConfig] = None


class DescribeQueueResponse(BaseModel):
    Queue_1: Optional[Queue] = Field(None, alias='Queue')


class DescribeQuickConnectResponse(BaseModel):
    QuickConnect_1: Optional[QuickConnect] = Field(None, alias='QuickConnect')


class DescribeRoutingProfileResponse(BaseModel):
    RoutingProfile_1: Optional[RoutingProfile] = Field(None, alias='RoutingProfile')


class DescribeSecurityProfileResponse(BaseModel):
    SecurityProfile_1: Optional[SecurityProfile] = Field(None, alias='SecurityProfile')


class DescribeUserHierarchyGroupResponse(BaseModel):
    HierarchyGroup_1: Optional[HierarchyGroup] = Field(None, alias='HierarchyGroup')


class GetMetricDataRequest(BaseModel):
    EndTime: Timestamp
    Filters_1: Filters = Field(..., alias='Filters')
    Groupings_1: Optional[Groupings] = Field(None, alias='Groupings')
    HistoricalMetrics_1: HistoricalMetrics = Field(..., alias='HistoricalMetrics')
    MaxResults: Optional[MaxResult100] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    StartTime: Timestamp


class GetMetricDataResponse(BaseModel):
    MetricResults: Optional[HistoricalMetricResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class GetTaskTemplateResponse(BaseModel):
    Arn: TaskTemplateArn
    Constraints: Optional[TaskTemplateConstraints] = None
    ContactFlowId_1: Optional[ContactFlowId] = Field(None, alias='ContactFlowId')
    CreatedTime: Optional[Timestamp] = None
    Defaults: Optional[TaskTemplateDefaults] = None
    Description: Optional[TaskTemplateDescription] = None
    Fields: Optional[TaskTemplateFields] = None
    Id: TaskTemplateId
    InstanceId_1: Optional[InstanceId] = Field(None, alias='InstanceId')
    LastModifiedTime: Optional[Timestamp] = None
    Name: TaskTemplateName
    Status: Optional[TaskTemplateStatus] = None
    Tags: Optional[TagMap] = None


class HoursOfOperation(BaseModel):
    Config: Optional[HoursOfOperationConfigList] = None
    Description: Optional[HoursOfOperationDescription] = None
    HoursOfOperationArn: Optional[ARN] = None
    HoursOfOperationId_1: Optional[HoursOfOperationId] = Field(
        None, alias='HoursOfOperationId'
    )
    Name: Optional[CommonNameLength127] = None
    Tags: Optional[TagMap] = None
    TimeZone_1: Optional[TimeZone] = Field(None, alias='TimeZone')


class ListRulesResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    RuleSummaryList_1: RuleSummaryList = Field(..., alias='RuleSummaryList')


class ListTaskTemplatesResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    TaskTemplates: Optional[TaskTemplateList] = None


class MetricV2(BaseModel):
    MetricFilters: Optional[MetricFiltersV2List] = None
    Name: Optional[MetricNameV2] = None
    Threshold: Optional[ThresholdCollections] = None


class MetricsV2(RootModel[List[MetricV2]]):
    root: List[MetricV2]


class RuleAction(BaseModel):
    ActionType_1: ActionType = Field(..., alias='ActionType')
    AssignContactCategoryAction: Optional[AssignContactCategoryActionDefinition] = None
    EventBridgeAction: Optional[EventBridgeActionDefinition] = None
    SendNotificationAction: Optional[SendNotificationActionDefinition] = None
    TaskAction: Optional[TaskActionDefinition] = None


class RuleActions(RootModel[List[RuleAction]]):
    root: List[RuleAction]


class SearchSecurityProfilesResponse(BaseModel):
    ApproximateTotalCount_1: Optional[ApproximateTotalCount] = Field(
        None, alias='ApproximateTotalCount'
    )
    NextToken: Optional[NextToken2500] = None
    SecurityProfiles: Optional[SecurityProfilesSearchSummaryList] = None


class UpdateParticipantRoleConfigChannelInfo(BaseModel):
    Chat: Optional[ChatParticipantRoleConfig] = None


class UpdateParticipantRoleConfigRequest(BaseModel):
    ChannelConfiguration: UpdateParticipantRoleConfigChannelInfo


class UpdateRuleRequest(BaseModel):
    Actions: RuleActions
    Function: RuleFunction
    Name: RuleName
    PublishStatus: RulePublishStatus


class ChannelConfiguration(BaseModel):
    Chat: Optional[ChatParticipantRoleConfig] = None


class ContactParticipantRoleConfigInstanceIdContactIdPutRequest(BaseModel):
    ChannelConfiguration_1: ChannelConfiguration = Field(
        ...,
        alias='ChannelConfiguration',
        description='Configuration information for the chat participant role.',
    )


class MetricsDataPostRequest(BaseModel):
    EndTime: datetime = Field(
        ...,
        description='<p>The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be later than the start time timestamp. It cannot be later than the current timestamp.</p> <p>The time range between the start and end time must be less than 24 hours.</p>',
    )
    Filters: List[FilterV2] = Field(
        ...,
        description='<p>The filters to apply to returned metrics. You can filter on the following resources:</p> <ul> <li> <p>Queues</p> </li> <li> <p>Routing profiles</p> </li> <li> <p>Agents</p> </li> <li> <p>Channels</p> </li> <li> <p>User hierarchy groups</p> </li> </ul> <p>At least one filter must be passed from queues, routing profiles, agents, or user hierarchy groups.</p> <p>To filter by phone number, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-historical-metrics-report.html">Create a historical metrics report</a> in the <i>Amazon Connect Administrator\'s Guide</i>.</p> <p>Note the following limits:</p> <ul> <li> <p> <b>Filter keys</b>: A maximum of 5 filter keys are supported in a single request. Valid filter keys: <code>QUEUE</code> | <code>ROUTING_PROFILE</code> | <code>AGENT</code> | <code>CHANNEL</code> | <code>AGENT_HIERARCHY_LEVEL_ONE</code> | <code>AGENT_HIERARCHY_LEVEL_TWO</code> | <code>AGENT_HIERARCHY_LEVEL_THREE</code> | <code>AGENT_HIERARCHY_LEVEL_FOUR</code> | <code>AGENT_HIERARCHY_LEVEL_FIVE</code> </p> </li> <li> <p> <b>Filter values</b>: A maximum of 100 filter values are supported in a single request. For example, a <code>GetMetricDataV2</code> request can filter by 50 queues, 35 agents, and 15 routing profiles for a total of 100 filter values. <code>VOICE</code>, <code>CHAT</code>, and <code>TASK</code> are valid <code>filterValue</code> for the <code>CHANNEL</code> filter key.</p> </li> </ul>',
        max_length=5,
        min_length=1,
    )
    Groupings: Optional[List[GroupingV2]] = Field(
        None,
        description='<p>The grouping applied to the metrics that are returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values that are returned apply to the metrics for each queue. They are not aggregated for all queues.</p> <p>If no grouping is specified, a summary of all metrics is returned.</p> <p>Valid grouping keys: <code>QUEUE</code> | <code>ROUTING_PROFILE</code> | <code>AGENT</code> | <code>CHANNEL</code> | <code>AGENT_HIERARCHY_LEVEL_ONE</code> | <code>AGENT_HIERARCHY_LEVEL_TWO</code> | <code>AGENT_HIERARCHY_LEVEL_THREE</code> | <code>AGENT_HIERARCHY_LEVEL_FOUR</code> | <code>AGENT_HIERARCHY_LEVEL_FIVE</code> </p>',
        max_length=2,
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    Metrics: List[MetricV2] = Field(
        ...,
        description='<p>The metrics to retrieve. Specify the name, groupings, and filters for each metric. The following historical metrics are available. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical metrics definitions</a> in the <i>Amazon Connect Administrator\'s Guide</i>.</p> <dl> <dt>AGENT_ADHERENT_TIME</dt> <dd> <p>This metric is available only in Amazon Web Services Regions where <a href="https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region">Forecasting, capacity planning, and scheduling</a> is available.</p> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy </p> </dd> <dt>AGENT_NON_RESPONSE</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy </p> </dd> <dt>AGENT_OCCUPANCY</dt> <dd> <p>Unit: Percentage</p> <p>Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy </p> </dd> <dt>AGENT_SCHEDULE_ADHERENCE</dt> <dd> <p>This metric is available only in Amazon Web Services Regions where <a href="https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region">Forecasting, capacity planning, and scheduling</a> is available.</p> <p>Unit: Percent</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>AGENT_SCHEDULED_TIME</dt> <dd> <p>This metric is available only in Amazon Web Services Regions where <a href="https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region">Forecasting, capacity planning, and scheduling</a> is available.</p> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>AVG_ABANDON_TIME</dt> <dd> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>AVG_AFTER_CONTACT_WORK_TIME</dt> <dd> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>AVG_AGENT_CONNECTING_TIME</dt> <dd> <p>Unit: Seconds</p> <p>Valid metric filter key: <code>INITIATION_METHOD</code>. For now, this metric only supports the following as <code>INITIATION_METHOD</code>: <code>INBOUND</code> | <code>OUTBOUND</code> | <code>CALLBACK</code> | <code>API</code> </p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>AVG_HANDLE_TIME</dt> <dd> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>AVG_HOLD_TIME</dt> <dd> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>AVG_INTERACTION_AND_HOLD_TIME</dt> <dd> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>AVG_INTERACTION_TIME</dt> <dd> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile</p> </dd> <dt>AVG_QUEUE_ANSWER_TIME</dt> <dd> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile</p> </dd> <dt>CONTACTS_ABANDONED</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>CONTACTS_CREATED</dt> <dd> <p>Unit: Count</p> <p>Valid metric filter key: <code>INITIATION_METHOD</code> </p> <p>Valid groupings and filters: Queue, Channel, Routing Profile</p> </dd> <dt>CONTACTS_HANDLED</dt> <dd> <p>Unit: Count</p> <p>Valid metric filter key: <code>INITIATION_METHOD</code>, <code>DISCONNECT_REASON</code> </p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>CONTACTS_HOLD_ABANDONS</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>CONTACTS_QUEUED</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>CONTACTS_TRANSFERRED_OUT</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>CONTACTS_TRANSFERRED_OUT_BY_AGENT</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>CONTACTS_TRANSFERRED_OUT_FROM_QUEUE</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>MAX_QUEUED_TIME</dt> <dd> <p>Unit: Seconds</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy</p> </dd> <dt>SERVICE_LEVEL</dt> <dd> <p>You can include up to 20 SERVICE_LEVEL metrics in a request.</p> <p>Unit: Percent</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile</p> <p>Threshold: For <code>ThresholdValue</code>, enter any whole number from 1 to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must enter <code>LT</code> (for "Less than"). </p> </dd> <dt>SUM_CONTACTS_ANSWERED_IN_X</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile</p> <p>Threshold: For <code>ThresholdValue</code>, enter any whole number from 1 to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must enter <code>LT</code> (for "Less than"). </p> </dd> <dt>SUM_CONTACTS_ABANDONED_IN_X</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile</p> <p>Threshold: For <code>ThresholdValue</code>, enter any whole number from 1 to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must enter <code>LT</code> (for "Less than"). </p> </dd> <dt>SUM_CONTACTS_DISCONNECTED </dt> <dd> <p>Valid metric filter key: <code>DISCONNECT_REASON</code> </p> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile</p> </dd> <dt>SUM_RETRY_CALLBACK_ATTEMPTS</dt> <dd> <p>Unit: Count</p> <p>Valid groupings and filters: Queue, Channel, Routing Profile</p> </dd> </dl>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2500)] = Field(
        None,
        description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
    )
    ResourceArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the resource. This includes the <code>instanceId</code> an Amazon Connect instance.',
    )
    StartTime: datetime = Field(
        ...,
        description='The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be before the end time timestamp. The time range between the start and end time must be less than 24 hours. The start time cannot be earlier than 14 days before the time of the request. Historical metrics are available for 14 days.',
    )


class RulesInstanceIdPostRequest(BaseModel):
    Actions: List[RuleAction] = Field(
        ..., description='A list of actions to be run when the rule is triggered.'
    )
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    Function: str = Field(..., description='The conditions of the rule.')
    Name: constr(pattern=r'^[0-9a-zA-Z._-]+', min_length=1, max_length=200) = Field(
        ..., description='A unique name for the rule.'
    )
    PublishStatus_1: PublishStatus = Field(
        ..., alias='PublishStatus', description='The publish status of the rule.'
    )
    TriggerEventSource_1: TriggerEventSource = Field(
        ...,
        alias='TriggerEventSource',
        description='The name of the event source. This field is required if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> ',
    )


class RulesInstanceIdRuleIdPutRequest(BaseModel):
    Actions: List[RuleAction] = Field(
        ..., description='A list of actions to be run when the rule is triggered.'
    )
    Function: str = Field(..., description='The conditions of the rule.')
    Name: constr(pattern=r'^[0-9a-zA-Z._-]+', min_length=1, max_length=200) = Field(
        ...,
        description='The name of the rule. You can change the name only if <code>TriggerEventSource</code> is one of the following values: <code>OnZendeskTicketCreate</code> | <code>OnZendeskTicketStatusUpdate</code> | <code>OnSalesforceCaseCreate</code> ',
    )
    PublishStatus_1: PublishStatus = Field(
        ..., alias='PublishStatus', description='The publish status of the rule.'
    )


class CreateRuleRequest(BaseModel):
    Actions: RuleActions
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    Function: RuleFunction
    Name: RuleName
    PublishStatus: RulePublishStatus
    TriggerEventSource: RuleTriggerEventSource


class DescribeHoursOfOperationResponse(BaseModel):
    HoursOfOperation_1: Optional[HoursOfOperation] = Field(
        None, alias='HoursOfOperation'
    )


class GetMetricDataV2Request(BaseModel):
    EndTime: Timestamp
    Filters: FiltersV2List
    Groupings: Optional[GroupingsV2] = None
    MaxResults: Optional[MaxResult100] = None
    Metrics: MetricsV2
    NextToken: Optional[NextToken2500] = None
    ResourceArn: ARN
    StartTime: Timestamp


class MetricDataV2(BaseModel):
    Metric: Optional[MetricV2] = None
    Value_1: Optional[Value] = Field(None, alias='Value')


class Rule(BaseModel):
    Actions: RuleActions
    CreatedTime: Timestamp
    Function: RuleFunction
    LastUpdatedBy: ARN
    LastUpdatedTime: Timestamp
    Name: RuleName
    PublishStatus: RulePublishStatus
    RuleArn: ARN
    RuleId_1: RuleId = Field(..., alias='RuleId')
    Tags: Optional[TagMap] = None
    TriggerEventSource: RuleTriggerEventSource


class DescribeRuleResponse(BaseModel):
    Rule_1: Rule = Field(..., alias='Rule')


class MetricDataCollectionsV2(RootModel[List[MetricDataV2]]):
    root: List[MetricDataV2]


class MetricResultV2(BaseModel):
    Collections: Optional[MetricDataCollectionsV2] = None
    Dimensions: Optional[DimensionsV2Map] = None


class MetricResultsV2(RootModel[List[MetricResultV2]]):
    root: List[MetricResultV2]


class GetMetricDataV2Response(BaseModel):
    MetricResults: Optional[MetricResultsV2] = None
    NextToken: Optional[NextToken2500] = None


class QueueSearchConditionList(RootModel[List[QueueSearchCriteria]]):
    root: List[QueueSearchCriteria]


class QueueSearchCriteria(BaseModel):
    AndConditions: Optional[QueueSearchConditionList] = None
    OrConditions: Optional[QueueSearchConditionList] = None
    QueueTypeCondition: Optional[SearchableQueueType] = None
    StringCondition_1: Optional[StringCondition] = Field(None, alias='StringCondition')


class RoutingProfileSearchConditionList(RootModel[List[RoutingProfileSearchCriteria]]):
    root: List[RoutingProfileSearchCriteria]


class RoutingProfileSearchCriteria(BaseModel):
    AndConditions: Optional[RoutingProfileSearchConditionList] = None
    OrConditions: Optional[RoutingProfileSearchConditionList] = None
    StringCondition_1: Optional[StringCondition] = Field(None, alias='StringCondition')


class SearchQueuesRequest(BaseModel):
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    MaxResults: Optional[MaxResult100] = None
    NextToken: Optional[NextToken2500] = None
    SearchCriteria: Optional[QueueSearchCriteria] = None
    SearchFilter: Optional[QueueSearchFilter] = None


class SearchRoutingProfilesRequest(BaseModel):
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    MaxResults: Optional[MaxResult100] = None
    NextToken: Optional[NextToken2500] = None
    SearchCriteria: Optional[RoutingProfileSearchCriteria] = None
    SearchFilter: Optional[RoutingProfileSearchFilter] = None


class SearchSecurityProfilesRequest(BaseModel):
    InstanceId_1: InstanceId = Field(..., alias='InstanceId')
    MaxResults: Optional[MaxResult100] = None
    NextToken: Optional[NextToken2500] = None
    SearchCriteria: Optional[SecurityProfileSearchCriteria] = None
    SearchFilter: Optional[SecurityProfilesSearchFilter] = None


class SearchUsersRequest(BaseModel):
    InstanceId_1: Optional[InstanceId] = Field(None, alias='InstanceId')
    MaxResults: Optional[MaxResult100] = None
    NextToken: Optional[NextToken2500] = None
    SearchCriteria: Optional[UserSearchCriteria] = None
    SearchFilter: Optional[UserSearchFilter] = None


class SecurityProfileSearchConditionList(
    RootModel[List[SecurityProfileSearchCriteria]]
):
    root: List[SecurityProfileSearchCriteria]


class SecurityProfileSearchCriteria(BaseModel):
    AndConditions: Optional[SecurityProfileSearchConditionList] = None
    OrConditions: Optional[SecurityProfileSearchConditionList] = None
    StringCondition_1: Optional[StringCondition] = Field(None, alias='StringCondition')


class UserSearchConditionList(RootModel[List[UserSearchCriteria]]):
    root: List[UserSearchCriteria]


class UserSearchCriteria(BaseModel):
    AndConditions: Optional[UserSearchConditionList] = None
    HierarchyGroupCondition_1: Optional[HierarchyGroupCondition] = Field(
        None, alias='HierarchyGroupCondition'
    )
    OrConditions: Optional[UserSearchConditionList] = None
    StringCondition_1: Optional[StringCondition] = Field(None, alias='StringCondition')


class SearchCriteria(BaseModel):
    AndConditions: Optional[QueueSearchConditionList] = None
    OrConditions: Optional[QueueSearchConditionList] = None
    QueueTypeCondition: Optional[SearchableQueueType] = None
    StringCondition_1: Optional[StringCondition] = Field(None, alias='StringCondition')


class SearchQueuesPostRequest(BaseModel):
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[constr(min_length=1, max_length=2500)] = Field(
        None,
        description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
    )
    SearchCriteria_1: Optional[SearchCriteria] = Field(
        None,
        alias='SearchCriteria',
        description='<p>The search criteria to be used to return queues.</p> <note> <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p> </note>',
    )
    SearchFilter_1: Optional[SearchFilter] = Field(
        None,
        alias='SearchFilter',
        description='Filters to be applied to search results.',
    )


class SearchCriteria1(BaseModel):
    AndConditions: Optional[RoutingProfileSearchConditionList] = None
    OrConditions: Optional[RoutingProfileSearchConditionList] = None
    StringCondition_1: Optional[StringCondition] = Field(None, alias='StringCondition')


class SearchRoutingProfilesPostRequest(BaseModel):
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[constr(min_length=1, max_length=2500)] = Field(
        None,
        description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
    )
    SearchCriteria: Optional[SearchCriteria1] = Field(
        None,
        description='<p>The search criteria to be used to return routing profiles.</p> <note> <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p> </note>',
    )
    SearchFilter_1: Optional[SearchFilter] = Field(
        None,
        alias='SearchFilter',
        description='Filters to be applied to search results.',
    )


class SearchCriteria2(BaseModel):
    AndConditions: Optional[SecurityProfileSearchConditionList] = None
    OrConditions: Optional[SecurityProfileSearchConditionList] = None
    StringCondition_1: Optional[StringCondition] = Field(None, alias='StringCondition')


class SearchSecurityProfilesPostRequest(BaseModel):
    InstanceId: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[constr(min_length=1, max_length=2500)] = Field(
        None,
        description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
    )
    SearchCriteria: Optional[SearchCriteria2] = Field(
        None,
        description='<p>The search criteria to be used to return security profiles.</p> <note> <p>The <code>name</code> field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.</p> </note>',
    )
    SearchFilter_1: Optional[SearchFilter] = Field(
        None,
        alias='SearchFilter',
        description='Filters to be applied to search results.',
    )


class SearchCriteria3(BaseModel):
    AndConditions: Optional[UserSearchConditionList] = None
    HierarchyGroupCondition_1: Optional[HierarchyGroupCondition] = Field(
        None, alias='HierarchyGroupCondition'
    )
    OrConditions: Optional[UserSearchConditionList] = None
    StringCondition_1: Optional[StringCondition] = Field(None, alias='StringCondition')


class SearchUsersPostRequest(BaseModel):
    InstanceId: Optional[constr(min_length=1, max_length=100)] = Field(
        None,
        description='The identifier of the Amazon Connect instance. You can <a href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find the instance ID</a> in the Amazon Resource Name (ARN) of the instance.',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return per page.'
    )
    NextToken: Optional[constr(min_length=1, max_length=2500)] = Field(
        None,
        description='The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.',
    )
    SearchCriteria: Optional[SearchCriteria3] = Field(
        None,
        description='<p>The search criteria to be used to return users.</p> <note> <p>The <code>name</code> and <code>description</code> fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results. </p> </note>',
    )
    SearchFilter_1: Optional[SearchFilter] = Field(
        None,
        alias='SearchFilter',
        description='Filters to be applied to search results.',
    )


QueueSearchConditionList.model_rebuild()
RoutingProfileSearchConditionList.model_rebuild()
SearchSecurityProfilesRequest.model_rebuild()
SearchUsersRequest.model_rebuild()
SecurityProfileSearchConditionList.model_rebuild()
UserSearchConditionList.model_rebuild()
